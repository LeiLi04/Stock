//@version=6
strategy("ChanLun Pro Strict v15", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.05, pyramiding=10)

// ==============================
// Library: DrawingLib
// ==============================
type GCManager
    array<line> lines
    array<box> boxes
    array<label> labels
    int limit

method init(GCManager this, int limit=400) =>
    this.lines := array.new<line>()
    this.boxes := array.new<box>()
    this.labels := array.new<label>()
    this.limit := limit

method drawLine(GCManager this, int x1, float y1, int x2, float y2, string xloc_=xloc.bar_index, color color_=color.blue, int width=1, string style=line.style_solid) =>
    l = line.new(x1, y1, x2, y2, xloc=xloc_, color=color_, width=width, style=style)
    this.lines.push(l)
    if this.lines.size() > this.limit
        line.delete(this.lines.shift())
    l

method drawBox(GCManager this, int l, float t, int r, float b, string xloc_=xloc.bar_index, color border=color.blue, color bg=na, string txt="", color txt_color=color.white) =>
    _bg = na(bg) ? color.new(color.blue, 90) : bg
    bx = box.new(l, t, r, b, xloc=xloc_, border_color=border, bgcolor=_bg, text=txt, text_color=txt_color, text_size=size.small, text_halign=text.align_right)
    this.boxes.push(bx)
    if this.boxes.size() > this.limit
        box.delete(this.boxes.shift())
    bx

method drawLabel(GCManager this, int x, float y, string txt, color color=color.blue, string style=label.style_label_up, color textcolor=color.white) =>
    lb = label.new(x, y, txt, xloc=xloc.bar_index, color=color, style=style, textcolor=textcolor, size=size.small)
    this.labels.push(lb)
    if this.labels.size() > this.limit
        label.delete(this.labels.shift())
    lb

// ==============================
// Library: ChanLunLib
// ==============================
type Stroke
    int startIdx
    float startPx
    int endIdx
    float endPx
    int dir // 1: Up, -1: Down
    float macdHist // MACD at end
    line l // Visualization line object
    bool confirmed

type Segment
    int startIdx
    float startPx
    int endIdx
    float endPx
    int dir
    float high
    float low
    int startStrokeIdx
    int endStrokeIdx
    line l

type CenterState
    bool inCenter
    float zg
    float zd
    int startStr
    int lastStr
    int enterDir
    int exitDir
    int ori // 1: Up, -1: Down, 0: Invalid
    int segCount
    int level

method copy(CenterState this) =>
    CenterState.new(this.inCenter, this.zg, this.zd, this.startStr, this.lastStr, this.enterDir, this.exitDir, this.ori, this.segCount, this.level)

type SegState
    bool inProgress
    int startStr
    int oldStartStr // Track previous segment start for drawing
    int lastStr
    int dir
    float fHigh
    float fLow
    int peakStr
    int lastEndBar
    float lastEndPx
    int strokeCnt

// Helper to get value at specific bar index
get_val_at_bar(series float src, int idx) =>
    ta.valuewhen(bar_index == idx, src, 0)

// Stroke Logic
method update(array<Stroke> strokes, bool hasPivot, bool isHigh, int idx, float price, int minBars) =>
    bool newStroke = false
    if hasPivot
        // Check if we have any strokes yet
        if strokes.size() == 0
            // Initialize first point (virtual) - waiting for second point to form a stroke
            // Actually, we need a previous pivot to form a stroke. 
            // This logic needs to be stateful. 
            // Let's adapt the logic from main.pine.
            na
        else
            lastS = strokes.get(strokes.size() - 1)
            // Logic adaptation required: The original code tracked lastPivotIndex/Price separately.
            // We will assume the caller manages the raw pivots and calls this when a potential stroke forms.
            na
    newStroke

// Simplified Stroke Creator (Caller tracks last pivot)
createStroke(int lpIdx, float lpPx, int idx, float price, int dir, float hist, bool confirmed=false) =>
    Stroke.new(lpIdx, lpPx, idx, price, dir, hist, na, confirmed)

method get_high(Stroke this) =>
    math.max(this.startPx, this.endPx)

method get_low(Stroke this) =>
    math.min(this.startPx, this.endPx)

// Center Logic
method update(CenterState st, array<Stroke> strokes, int lastCenterEndIdx, float atrv, bool useLock, float minH, float maxOverlap, float mergeRatio, array<CenterState> centers, array<Segment> superSegs) =>
    int status = 0 // 0: Nothing, 1: New, 2: Extension, 3: Finished
    sz = strokes.size()
    if sz >= 3
        if not st.inCenter
            // Ensure new center starts AFTER the last finished center
            if (sz - 3) > lastCenterEndIdx
                s0 = strokes.get(sz - 1)
                s1 = strokes.get(sz - 2)
                s2 = strokes.get(sz - 3)
                
                // 1. Price Overlap
                hi = math.min(math.max(s2.startPx, s2.endPx), math.min(math.max(s1.startPx, s1.endPx), math.max(s0.startPx, s0.endPx)))
                lo = math.max(math.min(s2.startPx, s2.endPx), math.max(math.min(s1.startPx, s1.endPx), math.min(s0.startPx, s0.endPx)))
                
                // 2. Direction
                d0 = s0.dir
                d1 = s1.dir
                d2 = s2.dir
                
                // Enter Direction (from previous stroke)
                enterD = 0
                if sz >= 4
                    enterD := strokes.get(sz - 4).dir
                
                // 3. Strict Pattern
                bool isDownCenter = (enterD == -1) and (d2 == 1) and (d1 == -1) and (d0 == 1)
                bool isUpCenter   = (enterD == 1)  and (d2 == -1) and (d1 == 1)  and (d0 == -1)
                
                // 4. New Filters
                // Height Filter
                float boxHeight = hi - lo
                bool passHeight = boxHeight >= minH * atrv

                // Overlap Filter
                bool passOverlap = true
                if centers.size() > 0
                    lastC = centers.get(centers.size()-1)
                    float pZG = lastC.zg
                    float pZD = lastC.zd
                    float overlap = math.max(0.0, math.min(hi, pZG) - math.max(lo, pZD))
                    float uni     = math.max(hi, pZG) - math.min(lo, pZD)
                    float ratio   = uni > 0 ? overlap/uni : 0
                    passOverlap := ratio <= maxOverlap
                
                // Lock Filter (Simplified: if useLock, require last center to be broken with trend i.e. ori!=0)
                // Exception: First center (centers.size() == 0)
                bool isLocked = useLock and centers.size() > 0 and st.ori == 0

                if (isDownCenter or isUpCenter) and (hi >= lo) and passHeight and passOverlap and not isLocked
                    // Try to merge with previous center
                    bool merged = false
                    if centers.size() > 0
                        lastC = centers.get(centers.size() - 1)
                        float prevZG = lastC.zg
                        float prevZD = lastC.zd
                        float interTop = math.min(prevZG, hi)
                        float interBot = math.max(prevZD, lo)
                        float interW = interTop - interBot
                        float prevW = prevZG - prevZD
                        float candW = hi - lo
                        
                        if interW > 0 and (interW / math.min(prevW, candW)) >= mergeRatio
                            // Merge
                            mergedZG = math.min(prevZG, hi)
                            mergedZD = math.max(prevZD, lo)
                            st.zg := mergedZG
                            st.zd := mergedZD
                            st.inCenter := true
                            st.startStr := sz - 3
                            st.lastStr := sz - 1
                            st.enterDir := enterD
                            st.ori := 0
                            
                            // Update previous stored center
                            lastC.zg := mergedZG
                            lastC.zd := mergedZD
                            
                            merged := true
                        
                    if not merged
                        st.zg := hi
                        st.zd := lo
                        st.inCenter := true
                        st.startStr := sz - 3
                        st.lastStr := sz - 1
                        st.enterDir := enterD
                        st.ori := 0
                        status := 1
        else
            // Extension
            s = strokes.get(sz - 1)
            hi2 = math.max(s.startPx, s.endPx)
            lo2 = math.min(s.startPx, s.endPx)
            newZG = math.min(st.zg, hi2)
            newZD = math.max(st.zd, lo2)
            
            if newZG >= newZD
                st.zg := newZG
                st.zd := newZD
                st.lastStr := sz - 1
                status := 2
            else
                // Break
                st.exitDir := s.dir
                if st.exitDir == st.enterDir
                    st.ori := st.exitDir
                else
                    st.ori := 0
                st.inCenter := false
                status := 3
    status

// Center Logic (Segment Based)
method update(CenterState st, array<Segment> segs, int lastCenterEndIdx, float atrv, bool useLock, float minH, float maxOverlap, float mergeRatio, array<CenterState> centers, array<Segment> superSegs, bool relax_center_rule) =>
    int status = 0 // 0: Nothing, 1: New, 2: Extension, 3: Finished, 4: Upgrade
    sz = segs.size()
    if sz >= 3
        if not st.inCenter
            // Ensure new center starts AFTER the last finished center
            if (sz - 3) > lastCenterEndIdx
                s0 = segs.get(sz - 1)
                s1 = segs.get(sz - 2)
                s2 = segs.get(sz - 3)
                
                // 1. Price Overlap
                hi = math.min(s2.high, math.min(s1.high, s0.high))
                lo = math.max(s2.low, math.max(s1.low, s0.low))
                
                // 2. Direction
                d0 = s0.dir
                d1 = s1.dir
                d2 = s2.dir
                
                // Enter Direction (from previous segment)
                enterD = 0
                if sz >= 4
                    enterD := segs.get(sz - 4).dir
                
                // 3. Strict Pattern
                bool isDownCenter = relax_center_rule ? (d2==1 and d1==-1 and d0==1) : ((enterD == -1) and (d2==1) and (d1==-1) and (d0==1))
                bool isUpCenter   = relax_center_rule ? (d2==-1 and d1==1 and d0==-1) : ((enterD == 1)  and (d2==-1) and (d1==1)  and (d0==-1))
                
                // 4. New Filters
                // Height Filter
                float boxHeight = hi - lo
                bool passHeight = boxHeight >= minH * atrv // Apply ATR filter if needed, or 0

                // Overlap Filter
                bool passOverlap = true
                if centers.size() > 0
                    lastC = centers.get(centers.size()-1)
                    float pZG = lastC.zg
                    float pZD = lastC.zd
                    float overlap = math.max(0.0, math.min(hi, pZG) - math.max(lo, pZD))
                    float uni     = math.max(hi, pZG) - math.min(lo, pZD)
                    float ratio   = uni > 0 ? overlap/uni : 0
                    passOverlap := ratio <= maxOverlap
                
                // Lock Filter
                bool isLocked = useLock and centers.size() > 0 and st.ori == 0

                if (isDownCenter or isUpCenter) and (hi >= lo) and passHeight and passOverlap and not isLocked
                    // Try to merge with previous center
                    bool merged = false
                    if centers.size() > 0
                        lastC = centers.get(centers.size() - 1)
                        float prevZG = lastC.zg
                        float prevZD = lastC.zd
                        float interTop = math.min(prevZG, hi)
                        float interBot = math.max(prevZD, lo)
                        float interW = interTop - interBot
                        float prevW = prevZG - prevZD
                        float candW = hi - lo
                        
                        if interW > 0 and (interW / math.min(prevW, candW)) >= mergeRatio
                            // Merge
                            mergedZG = math.min(prevZG, hi)
                            mergedZD = math.max(prevZD, lo)
                            st.zg := mergedZG
                            st.zd := mergedZD
                            st.inCenter := true
                            st.startStr := sz - 3
                            st.lastStr := sz - 1
                            st.enterDir := enterD
                            st.ori := 0
                            st.segCount := lastC.segCount + 3 // Inherit and add
                            st.level := lastC.level
                            
                            // Update previous stored center
                            lastC.zg := mergedZG
                            lastC.zd := mergedZD
                            lastC.segCount := st.segCount
                            
                            merged := true
                        
                    if not merged
                        st.zg := hi
                        st.zd := lo
                        st.inCenter := true
                        st.startStr := sz - 3
                        st.lastStr := sz - 1
                        st.enterDir := enterD
                        st.ori := 0
                        st.segCount := 3
                        st.level := 0
                        status := 1
        else
            // Extension
            s = segs.get(sz - 1)
            // Check overlap with current ZG/ZD
            float sHi = s.high
            float sLo = s.low
            
            // Overlap condition: sLo <= ZG and sHi >= ZD
            bool overlaps = sLo <= st.zg and sHi >= st.zd
            
            if overlaps
                st.zg := math.min(st.zg, sHi)
                st.zd := math.max(st.zd, sLo)
                st.lastStr := sz - 1
                st.segCount += 1
                status := 2
                
                // Check for Upgrade (9 segments)
                if st.segCount % 9 == 0
                    st.level += 1
                    status := 4
            else
                // Break
                st.exitDir := s.dir
                if st.exitDir == st.enterDir
                    st.ori := st.exitDir
                else
                    st.ori := 0
                st.inCenter := false
                status := 3
    status

// Segment Logic
method update(SegState st, array<Stroke> strokes, int minStrokes, array<Segment> segments) =>
    didFinalize = false
    sz = strokes.size()
    if sz > 0
        newStrIdx = sz - 1
        s = strokes.get(newStrIdx)
        
        if not st.inProgress and sz >= 3
            // Initialize Segment
            i0 = sz - 1, i2 = sz - 3
            s0 = strokes.get(i0), s2 = strokes.get(i2)
            
            // Determine direction based on High/Low of strokes
            dirCand = s0.endPx > s2.endPx ? 1 : -1
            
            st.dir := dirCand
            st.startStr := i2
            st.oldStartStr := i2 // Init
            st.lastStr := i0
            st.peakStr := i0
            st.strokeCnt := 3
            
            if st.dir > 0
                // Up Segment: Peak is the Highest High
                st.peakStr := math.max(s2.startPx, s2.endPx) > math.max(s0.startPx, s0.endPx) ? i2 : i0
                st.fLow := math.min(s0.startPx, s0.endPx)
            else
                // Down Segment: Peak is the Lowest Low
                st.peakStr := math.min(s2.startPx, s2.endPx) < math.min(s0.startPx, s0.endPx) ? i2 : i0
                st.fHigh := math.max(s0.startPx, s0.endPx)
            
            st.inProgress := true
            
        else if st.inProgress
            // Continue Segment
            if s.dir == st.dir
                st.lastStr := newStrIdx
                st.strokeCnt += 1
                if st.dir > 0
                    // Up Segment: Check for new High
                    sHi = math.max(s.startPx, s.endPx)
                    peakHi = math.max(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sHi >= peakHi
                        st.peakStr := newStrIdx
                    st.fLow := math.min(s.startPx, s.endPx)
                else
                    // Down Segment: Check for new Low
                    sLo = math.min(s.startPx, s.endPx)
                    peakLo = math.min(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sLo <= peakLo
                        st.peakStr := newStrIdx
                    st.fHigh := math.max(s.startPx, s.endPx)
            else
                // Counter Stroke
                st.strokeCnt += 1
                broke = false
                if st.dir > 0
                    if math.min(s.startPx, s.endPx) < st.fLow
                        broke := true
                else
                    if math.max(s.startPx, s.endPx) > st.fHigh
                        broke := true
                
                if broke
                    if st.strokeCnt >= minStrokes
                        // Finalize Segment
                        didFinalize := true
                        
                        // Start/End Strokes
                        sStart = strokes.get(st.startStr)
                        sPeak = strokes.get(st.peakStr)
                        
                        int sIdx = na
                        float sPx = na
                        int eIdx = na
                        float ePx = na
                        
                        if st.dir == 1 // Up Segment
                            sIdx := sStart.dir == 1 ? sStart.startIdx : sStart.endIdx
                            sPx := math.min(sStart.startPx, sStart.endPx)
                            eIdx := sPeak.dir == 1 ? sPeak.endIdx : sPeak.startIdx
                            ePx := math.max(sPeak.startPx, sPeak.endPx)
                        else // Down Segment
                            sIdx := sStart.dir == 1 ? sStart.endIdx : sStart.startIdx
                            sPx := math.max(sStart.startPx, sStart.endPx)
                            eIdx := sPeak.dir == 1 ? sPeak.startIdx : sPeak.endIdx
                            ePx := math.min(sPeak.startPx, sPeak.endPx)
                            
                        // Calculate True Segment High/Low (Iterate all strokes in range)
                        int iStart = math.min(st.startStr, st.peakStr)
                        int iEnd = math.max(st.startStr, st.peakStr)
                        float segHigh = -1e10
                        float segLow = 1e10
                        
                        for i = iStart to iEnd
                            strk = strokes.get(i)
                            float hi = math.max(strk.startPx, strk.endPx)
                            float lo = math.min(strk.startPx, strk.endPx)
                            segHigh := math.max(segHigh, hi)
                            segLow := math.min(segLow, lo)
                            
                        // Create Segment with True High/Low
                        Segment seg = Segment.new(sIdx, sPx, eIdx, ePx, st.dir, segHigh, segLow, iStart, iEnd, line(na))
                        segments.push(seg)

                        // New Segment starts from Peak
                        st.oldStartStr := st.startStr // Save previous start
                        st.startStr := st.peakStr
                        st.lastStr := newStrIdx
                        st.dir := -st.dir
                        st.peakStr := newStrIdx
                        st.strokeCnt := 1
                        st.fHigh := math.max(s.startPx, s.endPx)
                        st.fLow := math.min(s.startPx, s.endPx)
                    else
                        // Noise (Sub-segment correction)
                        st.lastStr := newStrIdx
                        if st.dir > 0
                            st.fLow := math.min(st.fLow, math.min(s.startPx, s.endPx))
                        else
                            st.fHigh := math.max(st.fHigh, math.max(s.startPx, s.endPx))
    didFinalize

// ==============================
// Main Script
// ==============================

// ==============================
// 1. 设置菜单 (Settings)
// ==============================
grpA = "1. 缠论结构 (Structure)"
lrb = input.int(1, "分型左右K数", minval=1, group=grpA)
minBarsStroke = input.int(4, "成笔最小跨度", minval=1, group=grpA)
useNorm = input.bool(true, "启用K线包含处理", group=grpA)
minStrokesPerSeg = input.int(3, "线段最少包含笔数", minval=3, group=grpA)
center_lock_until_break = input.bool(true,  "中枢锁：未破不新开", group=grpA)
center_min_height_atr   = input.float(0.0, "中枢最小高度(ATR倍)", step=0.05, group=grpA)
center_overlap_max_ratio= input.float(0.8, "与上个中枢重叠上限", step=0.05, group=grpA)
center_merge_ratio = input.float(0.5, "中枢合并重叠阈值(占较窄者比例)", step=0.05, minval=0.0, maxval=1.0, group=grpA)
use_segment_center = input.bool(true, "使用线段构建中枢 (Segment Centers)", group=grpA)
relax_center_rule = input.bool(true, "放宽中枢进入判定", group=grpA)

grpDisp = "2. 显示开关 (Display)"
showInclusion   = input.bool(false, "显示包含处理K线", group=grpDisp)
showStrokeLines = input.bool(true,  "显示 笔 (Strokes)", group=grpDisp)
showSegLines    = input.bool(true,  "显示 线段 (Segments)", group=grpDisp)
segLineWidth    = input.int(2,      "线段线宽", minval=1, maxval=10, group=grpDisp)
showCenter      = input.bool(true,  "显示 中枢 (Centers)", group=grpDisp)
showCenterLabels= input.bool(true,  "显示 中枢数值", group=grpDisp)
showSignalLabels= input.bool(true,  "显示 信号标签", group=grpDisp)

grpEnh = "4. 信号过滤"
use_gaussian_filter = input.bool(true, "启用高斯通道过滤 (C1)", group=grpEnh)
gauss_len = input.int(20, "高斯周期", group=grpEnh)
gauss_mult = input.float(2.0, "高斯带宽", step=0.1, group=grpEnh)
show_gaussian_bands = input.bool(false, "显示高斯通道", group=grpEnh)
macd_use_segment = input.bool(true, "C1 使用线段级背驰", group=grpEnh)

grpCol = "5. 颜色风格"
col_stroke_up = input.color(color.lime, "上涨笔", group=grpCol)
col_stroke_dn = input.color(color.red, "下跌笔", group=grpCol)
col_seg_up    = input.color(color.blue, "上涨线段", group=grpCol)
col_seg_dn    = input.color(color.blue, "下跌线段", group=grpCol)
col_center_bg = input.color(color.new(color.orange, 80), "中枢填充", group=grpCol)
col_text      = input.color(color.white, "文字颜色", group=grpCol)
col_label_buy = input.color(color.lime, "买点颜色", group=grpCol)
col_label_sell= input.color(color.red, "卖点颜色", group=grpCol)

grpMoney = "6. 资金管理"
useC1ForEntry = input.bool(true, "允许交易 C1", group=grpMoney)
risk_per_trade = input.float(1.0, "每笔风险 %", minval=0.1, step=0.1, group=grpMoney)
exit_R_Levels = input.string("1.0, 2.0", "止盈 R 级别", group=grpMoney)

grpInd = "3. 辅助指标"
showMA   = input.bool(false, "启用均线系统", group=grpInd)
ma1_len  = input.int(5, "MA 1", group=grpInd, inline="ma1")
show_ma1 = input.bool(true, "", group=grpInd, inline="ma1")
ma2_len  = input.int(10, "MA 2", group=grpInd, inline="ma2")
show_ma2 = input.bool(true, "", group=grpInd, inline="ma2")
ma3_len  = input.int(20, "MA 3", group=grpInd, inline="ma3")
show_ma3 = input.bool(true, "", group=grpInd, inline="ma3")
ma4_len  = input.int(30, "MA 4", group=grpInd, inline="ma4")
show_ma4 = input.bool(true, "", group=grpInd, inline="ma4")
ma5_len  = input.int(60, "MA 5", group=grpInd, inline="ma5")
show_ma5 = input.bool(true, "", group=grpInd, inline="ma5")

showBB   = input.bool(false, "启用布林带", group=grpInd)
bb_len   = input.int(20, "布林周期", group=grpInd)
bb_mult  = input.float(2.0, "布林带宽", group=grpInd)

useNeonCandles = input.bool(false, "强制覆盖K线颜色", group=grpCol)
col_candle_up = input.color(color.lime, "涨K线", group=grpCol)
col_candle_dn = input.color(color.red, "跌K线", group=grpCol)

// ==============================
// 2. 初始化 (Init)
// ==============================
var gc = GCManager.new()
if barstate.isfirst
    gc.init(400)

var strokes = array.new<Stroke>()
var segments = array.new<Segment>()
var superSegments = array.new<Segment>()
var centerSt = CenterState.new(false, na, na, na, na, 0, 0, 0, 0, 0)
var segSt = SegState.new(false, na, na, 0, na, na, na, na, na, 0)

// ==============================
// 3. 预处理 (Preprocessing)
// ==============================
[macd, signal, hist] = ta.macd(close, 12, 26, 9)
atrv = ta.atr(20)
var box activeCenterBox = na
var line liveSeg = line.new(na, na, na, na, width=segLineWidth)

// Gaussian
basis = ta.ema(close, gauss_len)
volatility = ta.ema(ta.tr(true), gauss_len)
upper_bound = basis + (gauss_mult * volatility)
lower_bound = basis - (gauss_mult * volatility)
p1 = plot(show_gaussian_bands ? upper_bound : na, "Upper", color=color.red)
p2 = plot(show_gaussian_bands ? lower_bound : na, "Lower", color=color.green)
fill(p1, p2, color=show_gaussian_bands ? color.new(color.gray, 95) : na)

// MA & BB
plot(showMA and show_ma1 ? ta.sma(close, ma1_len) : na, "MA1", color=color.yellow)
plot(showMA and show_ma2 ? ta.sma(close, ma2_len) : na, "MA2", color=color.white)
plot(showMA and show_ma3 ? ta.sma(close, ma3_len) : na, "MA3", color=color.aqua)
plot(showMA and show_ma4 ? ta.sma(close, ma4_len) : na, "MA4", color=color.orange)
plot(showMA and show_ma5 ? ta.sma(close, ma5_len) : na, "MA5", color=color.red, linewidth=2)

[bb_mid, bb_upper, bb_lower] = ta.bb(close, bb_len, bb_mult)
plot(showBB ? bb_upper : na, "BB Upper", color=color.new(color.blue, 80))
plot(showBB ? bb_lower : na, "BB Lower", color=color.new(color.blue, 80))
plot(showBB ? bb_mid : na, "BB Mid", color=color.new(color.orange, 80))

// Neon Candles
barcolor(useNeonCandles ? (close >= open ? col_candle_up : col_candle_dn) : na)

// Inclusion (K线包含)
var float nHigh = na, var float nLow = na, var int nDir = 0
if na(nHigh)
    nHigh := high, nLow := low, nDir := close >= open ? 1 : -1
else
    contain_prev = high <= nz(nHigh[1]) and low >= nz(nLow[1])
    contain_rev = high[1] <= high and low[1] >= low
    _ndir = nDir != 0 ? nDir : (close >= close[1] ? 1 : -1)
    if useNorm and (contain_prev or contain_rev)
        if _ndir >= 0 
            nHigh := math.max(nz(nHigh[1], high), high)
            nLow := math.max(nz(nLow[1], low), low)
        else          
            nHigh := math.min(nz(nHigh[1], high), high)
            nLow := math.min(nz(nLow[1], low), low)
    else
        nHigh := high, nLow := low, nDir := close >= close[1] ? 1 : -1

plot(showInclusion ? nHigh : na, color=color.new(color.aqua, 50), title="NormHigh")
plot(showInclusion ? nLow : na, color=color.new(color.fuchsia, 50), title="NormLow")

// ==============================
// 4. 严格缠论处理 (Strict ChanLun Processing) - Standard Pivot Fallback
// ==============================

// Data Structures

var array<Stroke> strictStrokes = array.new<Stroke>() // Alias for compatibility

// Inputs for Standard Logic
leftBars = input.int(1, "左侧K线数 (Left Bars)", minval=1, group="Standard Logic")
rightBars = input.int(1, "右侧K线数 (Right Bars)", minval=1, group="Standard Logic")

// Standard Pivot Detection
srcHigh = useNorm ? nHigh : high
srcLow = useNorm ? nLow : low
ph = ta.pivothigh(srcHigh, leftBars, rightBars)
pl = ta.pivotlow(srcLow, leftBars, rightBars)

// Stroke Generation
var int lastPivotIdx = na
var float lastPivotPx = na
var int lastPivotDir = 0 // 1: High, -1: Low

bool newStrokeAdded = false
var line liveStroke = line.new(na, na, na, na)

// Process New Pivot
if not na(ph) or not na(pl)
    int idx = bar_index - rightBars
    float px = na(ph) ? pl : ph
    int dir = na(ph) ? -1 : 1
    
    // Unified State Machine for Stroke Generation
    // Check if we can Extend
    bool canExtend = false
    if lastPivotDir == dir
        if (dir == 1 and px > lastPivotPx) or (dir == -1 and px < lastPivotPx)
            canExtend := true
    
    if canExtend
        // Extension
        if strokes.size() > 0
            lastS = strokes.get(strokes.size() - 1)
            lastS.endIdx := idx
            lastS.endPx := px
            lastS.macdHist := get_val_at_bar(hist, idx) // Update MACD
            
            // Update State
            lastPivotIdx := idx
            lastPivotPx := px
            
            if showStrokeLines
                line.set_xy2(lastS.l, idx, px)
                line.set_style(lastS.l, line.style_dotted) // Ensure dotted during extension
                
    else
        // Check if we can Create New (Flip)
        bool flipOk = (lastPivotDir != dir) and (lastPivotDir != 0)
        if flipOk and (idx - lastPivotIdx >= minBarsStroke)
            // Confirm Previous Stroke
            if strokes.size() > 0
                prev = strokes.get(strokes.size() - 1)
                if not prev.confirmed and not na(prev.l)
                    prev.confirmed := true
                    line.set_style(prev.l, line.style_solid)
                    // Color is already correct, no need to change
            
            // Create New Stroke (Unconfirmed, Dotted)
            Stroke s = Stroke.new(lastPivotIdx, lastPivotPx, idx, px, dir, get_val_at_bar(hist, idx), na, false)
            strokes.push(s)
            // strictStrokes.push(s) // Avoid reference sharing if not needed
            newStrokeAdded := true
            
            // Update State
            lastPivotIdx := idx
            lastPivotPx := px
            lastPivotDir := dir
            
            // Draw
            if showStrokeLines
                s.l := gc.drawLine(s.startIdx, s.startPx, s.endIdx, s.endPx, xloc.bar_index, dir == 1 ? col_stroke_up : col_stroke_dn, 2, line.style_dotted)
            
            // Reset Live Stroke
            line.set_xy1(liveStroke, idx, px)
            line.set_xy2(liveStroke, bar_index, close)
            
        else if lastPivotDir == 0 // Init
            lastPivotIdx := idx
            lastPivotPx := px
            lastPivotDir := dir

// Live Stroke Update
// Live Stroke Update
if not na(lastPivotIdx) and lastPivotDir != 0
    float y2 = lastPivotDir == -1 ? high : low
    line.set_xy1(liveStroke, lastPivotIdx, lastPivotPx)
    line.set_xy2(liveStroke, bar_index, y2)
    line.set_style(liveStroke, line.style_dotted)
    line.set_color(liveStroke, lastPivotDir == -1 ? col_stroke_up : col_stroke_dn)
else
    line.set_xy1(liveStroke, na, na), line.set_xy2(liveStroke, na, na)



// ==============================
// 5. 中枢 & 线段 (Centers & Segments)
// ==============================

var centers = array.new<CenterState>()
var int lastCenterEndIdx = -1 // Track the last stroke index of the previous center
if newStrokeAdded
    // Update Segments first (if using segment centers, we need segments)
    bool segFinished = segSt.update(strokes, minStrokesPerSeg, segments)
    
    if segFinished and showSegLines and segments.size() > 0
        seg = segments.get(segments.size() - 1)
        col = seg.dir == 1 ? col_seg_up : col_seg_dn
        
        int x1 = seg.startIdx
        float y1 = seg.startPx
        int x2 = seg.endIdx
        float y2 = seg.endPx
        
        seg.l := gc.drawLine(x1, y1, x2, y2, xloc.bar_index, col, segLineWidth)

// Update Centers (Every Bar)
int cStatus = 0
if use_segment_center
    cStatus := centerSt.update(segments, lastCenterEndIdx, atrv, center_lock_until_break, center_min_height_atr, center_overlap_max_ratio, center_merge_ratio, centers, superSegments, relax_center_rule)
else
    cStatus := centerSt.update(strokes, lastCenterEndIdx, atrv, center_lock_until_break, center_min_height_atr, center_overlap_max_ratio, center_merge_ratio, centers, superSegments)

// Draw Center Box
if centerSt.inCenter
    // Logic to draw/update box
    if showCenter
        // Determine Start/End indices based on Stroke or Segment
        int sIdx = na
        int eIdx = na
        if use_segment_center
            if segments.size() > centerSt.startStr and segments.size() > centerSt.lastStr
                sIdx := segments.get(centerSt.startStr).startIdx
                eIdx := segments.get(centerSt.lastStr).endIdx
        else
            if strokes.size() > centerSt.startStr and strokes.size() > centerSt.lastStr
                sIdx := strokes.get(centerSt.startStr).startIdx
                eIdx := strokes.get(centerSt.lastStr).endIdx
        
        if not na(sIdx) and not na(eIdx)
            txt = showCenterLabels ? "ZG:" + str.tostring(centerSt.zg, "#.##") + "\nZD:" + str.tostring(centerSt.zd, "#.##") : ""
            
            // Color based on Level
            color bgCol = col_center_bg
            if centerSt.level == 1
                bgCol := color.new(color.purple, 50)
                txt += "\nL1"
            else if centerSt.level >= 2
                bgCol := color.new(color.red, 50)
                txt += "\nL" + str.tostring(centerSt.level)
            
            color brd = color.new(color.orange, 0)
            
            if na(activeCenterBox)
                // New Center Box
                activeCenterBox := gc.drawBox(sIdx, centerSt.zg, eIdx, centerSt.zd, xloc.bar_index, brd, bgCol, txt, col_text)
            else
                // Update Existing Box
                box.set_left(activeCenterBox, sIdx)
                box.set_right(activeCenterBox, eIdx)
                box.set_top(activeCenterBox, centerSt.zg)
                box.set_bottom(activeCenterBox, centerSt.zd)
                box.set_text(activeCenterBox, txt)
                box.set_bgcolor(activeCenterBox, bgCol)
                box.set_border_color(activeCenterBox, brd)

if cStatus == 3 // Finished
    centers.push(centerSt.copy())
    lastCenterEndIdx := centerSt.lastStr // Update exclusion index
    
    if not na(activeCenterBox)
        // Finalize Box (Thicken border)
        box.set_border_width(activeCenterBox, 2 + math.max(0, centerSt.level))
        activeCenterBox := na

// Live Segment Drawing (Seamless) - Every Bar
if showSegLines and segSt.inProgress
    sStart = strokes.get(segSt.startStr)
    sEnd = strokes.get(segSt.lastStr)
    
    int lx1 = na
    float ly1 = na
    int lx2 = na
    float ly2 = na
    
    if segSt.dir == 1 // Current is UP
        // Start: Low of sStart
        lx1 := sStart.dir == 1 ? sStart.startIdx : sStart.endIdx
        ly1 := math.min(sStart.startPx, sStart.endPx)
        // End: High of sEnd
        lx2 := sEnd.dir == 1 ? sEnd.endIdx : sEnd.startIdx
        ly2 := math.max(sEnd.startPx, sEnd.endPx)
        
        line.set_color(liveSeg, col_seg_up)
    else // Current is DOWN
        // Start: High of sStart
        lx1 := sStart.dir == 1 ? sStart.endIdx : sStart.startIdx
        ly1 := math.max(sStart.startPx, sStart.endPx)
        // End: Low of sEnd
        lx2 := sEnd.dir == 1 ? sEnd.startIdx : sEnd.endIdx
        ly2 := math.min(sEnd.startPx, sEnd.endPx)
        
        line.set_color(liveSeg, col_seg_dn)
        
    line.set_xy1(liveSeg, lx1, ly1)
    line.set_xy2(liveSeg, lx2, ly2)
    line.set_style(liveSeg, line.style_dotted)
else
    line.set_xy1(liveSeg, na, na)
    line.set_xy2(liveSeg, na, na)

// ==============================
// 6. 信号 (Signals)
// ==============================
var bool c1Buy = false
var bool c1Sell = false
var float c1BuyPx = na
var float c1SellPx = na
var bool c2BuyTrig = false
var bool c2SellTrig = false
var bool c3Buy = false
var bool c3Sell = false

if strokes.size() >= 2 and newStrokeAdded
    curS = strokes.get(strokes.size() - 1)
    
    // C1 Logic (Trend Reversal)
    // ... (Already implemented)
    // Buy: Down Stroke, New Low, MACD Divergence, Gaussian Filter
    if curS.dir == -1
        l0 = curS.get_low()
        // Check Divergence
        isDiv = false
        // Simple Stroke Divergence
        if strokes.size() >= 3
            prevDownS = strokes.get(strokes.size() - 3)
            if l0 < prevDownS.get_low() and curS.macdHist > prevDownS.macdHist
                isDiv := true
        
        // Gaussian Filter
        isGauss = not use_gaussian_filter or (l0 <= get_val_at_bar(lower_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Buy := true
            c1BuyPx := l0
            c2BuyTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, l0, "C1 Buy", col_label_buy, label.style_label_up, col_text)

    // Sell: Up Stroke, New High, MACD Divergence, Gaussian Filter
    if curS.dir == 1
        h0 = curS.get_high()
        isDiv = false
        if strokes.size() >= 3
            prevUpS = strokes.get(strokes.size() - 3)
            if h0 > prevUpS.get_high() and curS.macdHist < prevUpS.macdHist
                isDiv := true
        
        isGauss = not use_gaussian_filter or (h0 >= get_val_at_bar(upper_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Sell := true
            c1SellPx := h0
            c2SellTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, h0, "C1 Sell", col_label_sell, label.style_label_down, col_text)

// C2 Logic (Second Confirmation)
// ------------------------------
if c1Buy and not c2BuyTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    // Wait for a Down stroke that doesn't break C1 Low
    if lastS.dir == -1
        if lastS.get_low() > c1BuyPx
            c2BuyTrig := true
            c1Buy := false // Reset C1 state
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Buy", col_label_buy, label.style_label_up, col_text)

if c1Sell and not c2SellTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    if lastS.dir == 1
        if lastS.get_high() < c1SellPx
            c2SellTrig := true
            c1Sell := false
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Sell", col_label_sell, label.style_label_down, col_text)

// C3 Logic (Trend Explosion)
// --------------------------
if strokes.size() > 0 and centers.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    lastC = centers.get(centers.size() - 1)
    
    // C3 Buy: Rising Center (ori=1) + Pullback Low >= ZG
    // We need to ensure we just left the center and pulled back.
    // The center finished at `lastC.lastStr`.
    // The stroke leaving the center is `lastC.lastStr + 1` (or `lastC.exitDir` stroke).
    // The pullback stroke is `lastC.lastStr + 2`.
    // So we check if `strokes.size() - 1` is the pullback stroke.
    
    // Check if last center was Up (Rising)
    if lastC.ori == 1
        // We need a pullback (Down stroke)
        if lastS.dir == -1
            // Check if this stroke is the first pullback after center?
            // Center ended at `lastC.lastStr`. 
            // Stroke `lastC.lastStr` was part of center.
            // Stroke `lastC.lastStr + 1` was the exit stroke (Up).
            // Stroke `lastC.lastStr + 2` is the pullback stroke (Down).
            // So index should be `lastC.lastStr + 2`.
            
            // However, `lastC.lastStr` is an index in `strokes`.
            // If `strokes.size() - 1 == lastC.lastStr + 2`
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                // Check if Pullback Low >= ZG (Strong) or ZD (Standard)?
                // Whitepaper: "Low for Buy ... 绝对不触及中枢边界 (ZG/ZD)"
                // Usually C3 Buy means Low > ZG (High of Center).
                if lastS.get_low() > lastC.zg
                    c3Buy := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Buy", col_label_buy, label.style_label_up, col_text)

    // C3 Sell: Falling Center (ori=-1) + Pullback High <= ZD
    if lastC.ori == -1
        // We need a pullback (Up stroke)
        if lastS.dir == 1
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                if lastS.get_high() < lastC.zd
                    c3Sell := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Sell", col_label_sell, label.style_label_down, col_text)

// ==============================
// 7. 交易执行 (Execution)
// ==============================
// Global Execution Variables
var float g_long_entry = na
var float g_long_sl    = na
var int   g_long_stage = 0 
var float g_short_entry = na
var float g_short_sl    = na
var int   g_short_stage = 0

// Helper Functions for Execution
do_buy(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size <= 0
        float riskPerShare = close - _sl
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_l = riskAmount / riskPerShare
            strategy.entry("Long", strategy.long, qty=qty_l, comment=_id)
            strategy.exit("L_TP1", from_entry="Long", qty_percent=33.3, limit=close + riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=close + 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

do_sell(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size >= 0
        float riskPerShare = _sl - close
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_s = riskAmount / riskPerShare
            strategy.entry("Short", strategy.short, qty=qty_s, comment=_id)
            strategy.exit("S_TP1", from_entry="Short", qty_percent=33.3, limit=close - riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=close - 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

// Execution Logic
// We need to detect if a signal *just* happened. 
// Our signal variables (c1Buy, etc.) are stateful flags.
// We should reset them after execution or check if they were set *this bar*.
// In the signal logic above, we set `c1Buy := true` when conditions are met.
// We need to ensure we don't re-execute on the same bar if already executed?
// Pine Script strategy executes on close.
// We can use `stroke_updated` flag if we had it.
// Let's check if `madePH` or `madePL` was true.
bool stroke_updated = newStrokeAdded

if useC1ForEntry and stroke_updated
    if c1Buy
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C1", c1BuyPx, risk_per_trade)
            g_long_entry := close
            g_long_sl := c1BuyPx
            g_long_stage := 0
        c1Buy := false // Reset flag

    if c1Sell
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C1", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c1Sell := false

if stroke_updated
    if c2BuyTrig
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C2", c1BuyPx, risk_per_trade)
            g_long_entry := close, g_long_sl := c1BuyPx, g_long_stage := 0
        c2BuyTrig := false

    if c2SellTrig
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C2", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c2SellTrig := false

    if c3Buy
        // Use lastZG as SL? Or c1BuyPx?
        // Whitepaper says C3 is pullback to ZG. SL should be below ZG or at ZG.
        // Let's use lastZG if available, else c1BuyPx (fallback)
        float sl_val = not na(centerSt.zg) ? centerSt.zg : c1BuyPx // Note: centerSt might be current center.
        // If C3, we are outside center. centerSt might be invalid or new.
        // We need the *confirmed* center's ZG.
        // We stored it in `centers` array.
        float lastZG = na
        if centers.size() > 0
            lastZG := centers.get(centers.size()-1).zg
        
        float final_sl = not na(lastZG) ? lastZG : c1BuyPx
        
        if do_buy("Long_C3", final_sl, risk_per_trade)
            g_long_entry := close
            g_long_sl := final_sl
            g_long_stage := 0
        c3Buy := false

    if c3Sell
        float lastZD = na
        if centers.size() > 0
            lastZD := centers.get(centers.size()-1).zd
        
        float final_sl_s = not na(lastZD) ? lastZD : c1SellPx
        
        if do_sell("Short_C3", final_sl_s, risk_per_trade)
            g_short_entry := close, g_short_sl := final_sl_s
            g_short_stage := 0
        c3Sell := false

// Dynamic Stop Loss & Profit Taking (3-Stage)
if strategy.position_size > 0 and not na(g_long_entry) and not na(g_long_sl)
    risk = g_long_entry - g_long_sl
    if high >= (g_long_entry + risk) and g_long_stage < 1
        g_long_stage := 1
        strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=g_long_entry + 2*risk, stop=g_long_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry, comment_profit="Run", comment_loss="SL_BE")
    if high >= (g_long_entry + 2*risk) and g_long_stage < 2
        g_long_stage := 2
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry + risk, comment_profit="Run", comment_loss="SL_1R")

if strategy.position_size < 0 and not na(g_short_entry) and not na(g_short_sl)
    risk = g_short_sl - g_short_entry
    if low <= (g_short_entry - risk) and g_short_stage < 1
        g_short_stage := 1
        strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=g_short_entry - 2*risk, stop=g_short_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry, comment_profit="Run", comment_loss="SL_BE")
    if low <= (g_short_entry - 2*risk) and g_short_stage < 2
        g_short_stage := 2
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry - risk, comment_profit="Run", comment_loss="SL_1R")

// Manual Aux Lines
man_Enable = input.bool(false, "启用手动辅助线", group=grpMoney)
man_EntryPrice_str = input.string("", "手动入场价", group=grpMoney)
man_EntryPrice_val = str.length(man_EntryPrice_str) == 0 ? na : str.tonumber(man_EntryPrice_str)

if man_Enable and not na(man_EntryPrice_val)
    line.new(bar_index, man_EntryPrice_val, bar_index+10, man_EntryPrice_val, color=color.white, width=2)
