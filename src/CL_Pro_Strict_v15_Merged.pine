//@version=6
strategy("ChanLun Pro Strict v15", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.05, pyramiding=10)

"""
Algorithm Summary:
    A professional-grade implementation of ChanLun (Zen/Entanglement Theory) for market analysis.
    Integrates Fractal Geometry (FenXing), Stroke (Bi), Segment (XianDuan), and Center (ZhongShu) 
    structures to identify high-probability trend reversals and continuations.

Symbol Legend:
    K : Raw Candlestick Data {Open, High, Low, Close}
    S : Stroke Sequence {s_0, s_1, ...}
    C : Center State {ZG, ZD, ...}
    
    Core Tensor Flow:
    Raw OHLC -> [Inclusion] -> Normalized K -> [Fractal] -> Pivots -> [Stroke Gen] -> Strokes -> [Center Gen] -> Centers -> [Signal] -> Trade
"""

// ==========================================================================
// LIBRARY: DrawingLib (Embedded)
// ==========================================================================

// step 1.1: 垃圾回收管理器 (Garbage Collection Manager)
// --------------------------------------------------------------------------
type GCManager
    array<line> lines    // Buffer for line objects
    array<box> boxes     // Buffer for box objects
    array<label> labels  // Buffer for label objects
    int limit            // Capacity constraint L

// step 1.2: 初始化 (Initialization)
// --------------------------------------------------------------------------
method init(GCManager this, int limit=400) =>
    this.lines := array.new<line>()
    this.boxes := array.new<box>()
    this.labels := array.new<label>()
    this.limit := limit

// step 1.3: 线条绘制与管理 (Line Drawing & GC)
// --------------------------------------------------------------------------
method drawLine(GCManager this, int x1, float y1, int x2, float y2, string xloc=xloc.bar_index, color color=color.blue, int width=1, string style=line.style_solid) =>
    l = line.new(x1, y1, x2, y2, xloc=xloc, color=color, width=width, style=style)
    this.lines.push(l)
    if this.lines.size() > this.limit
        line.delete(this.lines.shift())
    l

// step 1.4: 矩形绘制与管理 (Box Drawing & GC)
// --------------------------------------------------------------------------
method drawBox(GCManager this, int l, float t, int r, float b, string xloc=xloc.bar_index, color border=color.blue, color bg=na, string txt="", color txt_color=color.white) =>
    _bg = na(bg) ? color.new(color.blue, 90) : bg
    bx = box.new(l, t, r, b, xloc=xloc_, border_color=border, bgcolor=_bg, text=txt, text_color=txt_color, text_size=size.small, text_halign=text.align_right)
    this.boxes.push(bx)
    if this.boxes.size() > this.limit
        box.delete(this.boxes.shift())
    bx

// step 1.5: 标签绘制与管理 (Label Drawing & GC)
// --------------------------------------------------------------------------
method drawLabel(GCManager this, int x, float y, string txt, color color=color.blue, string style=label.style_label_up, color textcolor=color.white) =>
    lb = label.new(x, y, txt, xloc=xloc.bar_index, color=color, style=style, textcolor=textcolor, size=size.small)
    this.labels.push(lb)
    if this.labels.size() > this.limit
        label.delete(this.labels.shift())
    lb

// ==========================================================================
// LIBRARY: ChanLunLib (Embedded)
// ==========================================================================

// step 2.1: 笔 (Stroke / Bi)
// --------------------------------------------------------------------------
type Stroke
    int startIdx     // Start Bar Index
    float startPx    // Start Price
    int endIdx       // End Bar Index
    float endPx      // End Price
    int dir          // Direction: 1 (Up), -1 (Down)
    float macdHist   // MACD Histogram value at the end of stroke
    line l           // Visualization line object

// step 2.2: 中枢状态 (Center State)
// --------------------------------------------------------------------------
type CenterState
    bool inCenter    // Active flag
    float zg         // Upper bound
    float zd         // Lower bound
    int startStr     // Index of the first stroke in center
    int lastStr      // Index of the last stroke in center
    int enterDir     // Direction of the stroke entering the center
    int exitDir      // Direction of the stroke leaving the center
    int ori          // Orientation: 1 (Rising), -1 (Falling), 0 (Neutral)

method copy(CenterState this) =>
    CenterState.new(this.inCenter, this.zg, this.zd, this.startStr, this.lastStr, this.enterDir, this.exitDir, this.ori, this.segCount, this.level)

// step 2.3: 线段状态 (Segment State)
// --------------------------------------------------------------------------
type SegState
    bool inProgress  // Active flag
    int startStr     // Index of start stroke
    int oldStartStr  // Track previous segment start for drawing
    int lastStr      // Index of current end stroke
    int dir          // Direction: 1 (Up), -1 (Down)
    float fHigh      // Feature Sequence High
    float fLow       // Feature Sequence Low
    int peakStr      // Index of the stroke containing the peak price
    int lastEndBar   // Bar index of segment end
    float lastEndPx  // Price of segment end
    int strokeCnt    // Number of strokes in current segment

// step 2.4: 辅助函数 (Helpers)
// --------------------------------------------------------------------------
get_val_at_bar(float src, int idx) =>
    ta.valuewhen(bar_index == idx, src, 0)

// step 2.5: 笔更新 (Stroke Update)
// --------------------------------------------------------------------------
method update(array<Stroke> strokes, bool hasPivot, bool isHigh, int idx, float price, int minBars) =>
    bool newStroke = false
    if hasPivot
        if strokes.size() == 0
            na
        else
            lastS = strokes.get(strokes.size() - 1)
            na
    newStroke

// step 2.6: 笔构造工厂 (Stroke Factory)
// --------------------------------------------------------------------------
createStroke(int lpIdx, float lpPx, int idx, float price, int dir, float hist) =>
    Stroke.new(lpIdx, lpPx, idx, price, dir, hist, line(na))

method get_high(Stroke this) =>
    math.max(this.startPx, this.endPx)

method get_low(Stroke this) =>
    math.min(this.startPx, this.endPx)

// step 2.7: 中枢更新 (Center Update)
// --------------------------------------------------------------------------
method update(CenterState st, array<Stroke> strokes, int lastCenterEndIdx) =>
    int status = 0 // 0: Nothing, 1: New, 2: Extension, 3: Finished
    sz = strokes.size()
    
    // step 2.7a) 最小笔数检查
    if sz >= 3
        if not st.inCenter
            // step 2.7b) 新中枢判定
            if (sz - 3) > lastCenterEndIdx
                s0 = strokes.get(sz - 1)
                s1 = strokes.get(sz - 2)
                s2 = strokes.get(sz - 3)
                
                // Math: Intersection = [max(min(s_i)), min(max(s_i))]
                hi = math.min(math.max(s2.startPx, s2.endPx), math.min(math.max(s1.startPx, s1.endPx), math.max(s0.startPx, s0.endPx)))
                lo = math.max(math.min(s2.startPx, s2.endPx), math.max(math.min(s1.startPx, s1.endPx), math.min(s0.startPx, s0.endPx)))
                
                d0 = s0.dir
                d1 = s1.dir
                d2 = s2.dir
                
                enterD = 0
                if sz >= 4
                    enterD := strokes.get(sz - 4).dir
                
                bool isDownCenter = (enterD == -1) and (d2 == 1) and (d1 == -1) and (d0 == 1)
                bool isUpCenter   = (enterD == 1)  and (d2 == -1) and (d1 == 1)  and (d0 == -1)
                
                // 4. New Filters
                // Height Filter
                float boxHeight = hi - lo
                bool passHeight = boxHeight >= minH * atrv

                // Overlap Filter
                bool passOverlap = true
                if centers.size() > 0
                    lastC = centers.get(centers.size()-1)
                    float pZG = lastC.zg
                    float pZD = lastC.zd
                    float overlap = math.max(0.0, math.min(hi, pZG) - math.max(lo, pZD))
                    float uni     = math.max(hi, pZG) - math.min(lo, pZD)
                    float ratio   = uni > 0 ? overlap/uni : 0
                    passOverlap := ratio <= maxOverlap
                
                // Lock Filter (Simplified: if useLock, require last center to be broken with trend i.e. ori!=0)
                // Exception: First center (centers.size() == 0)
                bool isLocked = useLock and centers.size() > 0 and st.ori == 0

                if (isDownCenter or isUpCenter) and (hi >= lo) and passHeight and passOverlap and not isLocked
                    // Try to merge with previous center
                    bool merged = false
                    if centers.size() > 0
                        lastC = centers.get(centers.size() - 1)
                        float prevZG = lastC.zg
                        float prevZD = lastC.zd
                        float interTop = math.min(prevZG, hi)
                        float interBot = math.max(prevZD, lo)
                        float interW = interTop - interBot
                        float prevW = prevZG - prevZD
                        float candW = hi - lo
                        
                        if interW > 0 and (interW / math.min(prevW, candW)) >= mergeRatio
                            // Merge
                            mergedZG = math.min(prevZG, hi)
                            mergedZD = math.max(prevZD, lo)
                            st.zg := mergedZG
                            st.zd := mergedZD
                            st.inCenter := true
                            st.startStr := sz - 3
                            st.lastStr := sz - 1
                            st.enterDir := enterD
                            st.ori := 0
                            
                            // Update previous stored center
                            lastC.zg := mergedZG
                            lastC.zd := mergedZD
                            
                            merged := true
                        
                    if not merged
                        st.zg := hi
                        st.zd := lo
                        st.inCenter := true
                        st.startStr := sz - 3
                        st.lastStr := sz - 1
                        st.enterDir := enterD
                        st.ori := 0
                        status := 1
        else
            // step 2.7c) 中枢延伸与破坏
            s = strokes.get(sz - 1)
            hi2 = math.max(s.startPx, s.endPx)
            lo2 = math.min(s.startPx, s.endPx)
            newZG = math.min(st.zg, hi2)
            newZD = math.max(st.zd, lo2)
            
            if newZG >= newZD
                st.zg := newZG
                st.zd := newZD
                st.lastStr := sz - 1
                status := 2
            else
                st.exitDir := s.dir
                if st.exitDir == st.enterDir
                    st.ori := st.exitDir
                else
                    st.ori := 0
                st.inCenter := false
                status := 3
    status

// step 2.8: 线段更新 (Segment Update)
// --------------------------------------------------------------------------
method update(SegState st, array<Stroke> strokes, int minStrokes) =>
    didFinalize = false
    sz = strokes.size()
    if sz > 0
        newStrIdx = sz - 1
        s = strokes.get(newStrIdx)
        
        if not st.inProgress and sz >= 3
            // step 2.8a) 线段初始化
            i0 = sz - 1, i2 = sz - 3
            s0 = strokes.get(i0), s2 = strokes.get(i2)
            
            dirCand = s0.endPx > s2.endPx ? 1 : -1
            
            st.dir := dirCand
            st.startStr := i2
            st.oldStartStr := i2 // Init
            st.lastStr := i0
            st.peakStr := i0
            st.strokeCnt := 3
            
            if st.dir > 0
                st.peakStr := math.max(s2.startPx, s2.endPx) > math.max(s0.startPx, s0.endPx) ? i2 : i0
                st.fLow := math.min(s0.startPx, s0.endPx)
            else
                st.peakStr := math.min(s2.startPx, s2.endPx) < math.min(s0.startPx, s0.endPx) ? i2 : i0
                st.fHigh := math.max(s0.startPx, s0.endPx)
            
            st.inProgress := true
            
        else if st.inProgress
            // step 2.8b) 线段延伸
            if s.dir == st.dir
                st.lastStr := newStrIdx
                st.strokeCnt += 1
                if st.dir > 0
                    sHi = math.max(s.startPx, s.endPx)
                    peakHi = math.max(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sHi >= peakHi
                        st.peakStr := newStrIdx
                    st.fLow := math.min(s.startPx, s.endPx)
                else
                    sLo = math.min(s.startPx, s.endPx)
                    peakLo = math.min(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sLo <= peakLo
                        st.peakStr := newStrIdx
                    st.fHigh := math.max(s.startPx, s.endPx)
            else
                // step 2.8c) 线段破坏检查
                st.strokeCnt += 1
                broke = false
                if st.dir > 0
                    if math.min(s.startPx, s.endPx) < st.fLow
                        broke := true
                else
                    if math.max(s.startPx, s.endPx) > st.fHigh
                        broke := true
                
                if broke
                    if st.strokeCnt >= minStrokes
                        // step 2.8d) 线段终结
                        didFinalize := true
                        st.oldStartStr := st.startStr // Save previous start
                        st.startStr := st.peakStr
                        st.lastStr := newStrIdx
                        st.dir := -st.dir
                        st.peakStr := newStrIdx
                        st.strokeCnt := 1
                        st.fHigh := math.max(s.startPx, s.endPx)
                        st.fLow := math.min(s.startPx, s.endPx)
                    else
                        // Noise
                        st.lastStr := newStrIdx
                        if st.dir > 0
                            st.fLow := math.min(st.fLow, math.min(s.startPx, s.endPx))
                        else
                            st.fHigh := math.max(st.fHigh, math.max(s.startPx, s.endPx))
    didFinalize

// ==========================================================================
// MAIN SCRIPT: Strategy Logic
// ==========================================================================

// ==========================================================================
// STEP 01: 参数配置 (Configuration & Hyperparameters)
// ==========================================================================
grpA = "1. 缠论结构 (Structure)"
lrb = input.int(1, "分型左右K数", minval=1, group=grpA)
minBarsStroke = input.int(4, "成笔最小跨度", minval=1, group=grpA)
useNorm = input.bool(true, "启用K线包含处理", group=grpA)
minStrokesPerSeg = input.int(3, "线段最少包含笔数", minval=3, group=grpA)
center_lock_until_break = input.bool(true,  "中枢锁：未破不新开", group=grpA)
center_min_height_atr   = input.float(0.0, "中枢最小高度(ATR倍)", step=0.05, group=grpA)
center_overlap_max_ratio= input.float(0.8, "与上个中枢重叠上限", step=0.05, group=grpA)
center_merge_ratio = input.float(0.5, "中枢合并重叠阈值(占较窄者比例)", step=0.05, minval=0.0, maxval=1.0, group=grpA)
use_segment_center = input.bool(true, "使用线段构建中枢 (Segment Centers)", group=grpA)
relax_center_rule = input.bool(true, "放宽中枢进入判定", group=grpA)

grpDisp = "2. 显示开关 (Display)"
showInclusion   = input.bool(false, "显示包含处理K线", group=grpDisp)
showStrokeLines = input.bool(true,  "显示 笔 (Strokes)", group=grpDisp)
showSegLines    = input.bool(true,  "显示 线段 (Segments)", group=grpDisp)
segLineWidth    = input.int(2,      "线段线宽", minval=1, maxval=10, group=grpDisp)
showCenter      = input.bool(true,  "显示 中枢 (Centers)", group=grpDisp)
showCenterLabels= input.bool(true,  "显示 中枢数值", group=grpDisp)
showSignalLabels= input.bool(true,  "显示 信号标签", group=grpDisp)

grpEnh = "4. 信号过滤"
use_gaussian_filter = input.bool(true, "启用高斯通道过滤 (C1)", group=grpEnh)
gauss_len = input.int(20, "高斯周期", group=grpEnh)
gauss_mult = input.float(2.0, "高斯带宽", step=0.1, group=grpEnh)
show_gaussian_bands = input.bool(false, "显示高斯通道", group=grpEnh)
macd_use_segment = input.bool(true, "C1 使用线段级背驰", group=grpEnh)

grpCol = "5. 颜色风格"
col_stroke_up = input.color(color.lime, "上涨笔", group=grpCol)
col_stroke_dn = input.color(color.red, "下跌笔", group=grpCol)
col_seg_up    = input.color(color.blue, "上涨线段", group=grpCol)
col_seg_dn    = input.color(color.blue, "下跌线段", group=grpCol)
col_center_bg = input.color(color.new(color.orange, 80), "中枢填充", group=grpCol)
col_text      = input.color(color.white, "文字颜色", group=grpCol)
col_label_buy = input.color(color.lime, "买点颜色", group=grpCol)
col_label_sell= input.color(color.red, "卖点颜色", group=grpCol)

grpMoney = "6. 资金管理"
useC1ForEntry = input.bool(true, "允许交易 C1", group=grpMoney)
risk_per_trade = input.float(1.0, "每笔风险 %", minval=0.1, step=0.1, group=grpMoney)
exit_R_Levels = input.string("1.0, 2.0", "止盈 R 级别", group=grpMoney)

grpInd = "3. 辅助指标"
showMA   = input.bool(false, "启用均线系统", group=grpInd)
ma1_len  = input.int(5, "MA 1", group=grpInd, inline="ma1")
show_ma1 = input.bool(true, "", group=grpInd, inline="ma1")
ma2_len  = input.int(10, "MA 2", group=grpInd, inline="ma2")
show_ma2 = input.bool(true, "", group=grpInd, inline="ma2")
ma3_len  = input.int(20, "MA 3", group=grpInd, inline="ma3")
show_ma3 = input.bool(true, "", group=grpInd, inline="ma3")
ma4_len  = input.int(30, "MA 4", group=grpInd, inline="ma4")
show_ma4 = input.bool(true, "", group=grpInd, inline="ma4")
ma5_len  = input.int(60, "MA 5", group=grpInd, inline="ma5")
show_ma5 = input.bool(true, "", group=grpInd, inline="ma5")

showBB   = input.bool(false, "启用布林带", group=grpInd)
bb_len   = input.int(20, "布林周期", group=grpInd)
bb_mult  = input.float(2.0, "布林带宽", group=grpInd)

useNeonCandles = input.bool(false, "强制覆盖K线颜色", group=grpCol)
col_candle_up = input.color(color.lime, "涨K线", group=grpCol)
col_candle_dn = input.color(color.red, "跌K线", group=grpCol)

// ==========================================================================
// STEP 02: 系统初始化 (System Initialization)
// ==========================================================================
var gc = GCManager.new()
if barstate.isfirst
    gc.init(400)

var strokes = array.new<Stroke>()
var segments = array.new<Segment>()
var superSegments = array.new<Segment>()
var centerSt = CenterState.new(false, na, na, na, na, 0, 0, 0, 0, 0)
var segSt = SegState.new(false, na, na, 0, na, na, na, na, na, 0)

// ==========================================================================
// STEP 03: 数据预处理 (Data Preprocessing)
// ==========================================================================

// step 3.1: 基础指标计算 (Basic Indicators)
// --------------------------------------------------------------------------
[macd, signal, hist] = ta.macd(close, 12, 26, 9)
atrv = ta.atr(20)
var box activeCenterBox = na
var line liveSeg = line.new(na, na, na, na, width=segLineWidth)

// step 3.2: 高斯通道 (Gaussian Channel)
// --------------------------------------------------------------------------
basis = ta.ema(close, gauss_len)
volatility = ta.ema(ta.tr(true), gauss_len)
upper_bound = basis + (gauss_mult * volatility)
lower_bound = basis - (gauss_mult * volatility)
p1 = plot(show_gaussian_bands ? upper_bound : na, "Upper", color=color.red)
p2 = plot(show_gaussian_bands ? lower_bound : na, "Lower", color=color.green)
fill(p1, p2, color=show_gaussian_bands ? color.new(color.gray, 95) : na)

// step 3.3: 均线与布林带 (MA & BB)
// --------------------------------------------------------------------------
plot(showMA and show_ma1 ? ta.sma(close, ma1_len) : na, "MA1", color=color.yellow)
plot(showMA and show_ma2 ? ta.sma(close, ma2_len) : na, "MA2", color=color.white)
plot(showMA and show_ma3 ? ta.sma(close, ma3_len) : na, "MA3", color=color.aqua)
plot(showMA and show_ma4 ? ta.sma(close, ma4_len) : na, "MA4", color=color.orange)
plot(showMA and show_ma5 ? ta.sma(close, ma5_len) : na, "MA5", color=color.red, linewidth=2)

[bb_mid, bb_upper, bb_lower] = ta.bb(close, bb_len, bb_mult)
plot(showBB ? bb_upper : na, "BB Upper", color=color.new(color.blue, 80))
plot(showBB ? bb_lower : na, "BB Lower", color=color.new(color.blue, 80))
plot(showBB ? bb_mid : na, "BB Mid", color=color.new(color.orange, 80))

// Neon Candles
barcolor(useNeonCandles ? (close >= open ? col_candle_up : col_candle_dn) : na)

// step 3.4: K线包含处理 (K-Line Inclusion)
// --------------------------------------------------------------------------
var float nHigh = na, var float nLow = na, var int nDir = 0
if na(nHigh)
    nHigh := high, nLow := low, nDir := close >= open ? 1 : -1
else
    contain_prev = high <= nz(nHigh[1]) and low >= nz(nLow[1])
    contain_rev = high[1] <= high and low[1] >= low
    _ndir = nDir != 0 ? nDir : (close >= close[1] ? 1 : -1)
    if useNorm and (contain_prev or contain_rev)
        if _ndir >= 0 
            nHigh := math.max(nz(nHigh[1], high), high)
            nLow := math.max(nz(nLow[1], low), low)
        else          
            nHigh := math.min(nz(nHigh[1], high), high)
            nLow := math.min(nz(nLow[1], low), low)
    else
        nHigh := high, nLow := low, nDir := close >= close[1] ? 1 : -1

plot(showInclusion ? nHigh : na, color=color.new(color.aqua, 50), title="NormHigh")
plot(showInclusion ? nLow : na, color=color.new(color.fuchsia, 50), title="NormLow")

// ==========================================================================
// STEP 04: 严格缠论处理 (Strict ChanLun Processing)
// ==========================================================================

// Data Structures
var array<Stroke> strictStrokes = array.new<Stroke>() // Alias for compatibility

// Inputs for Standard Logic
leftBars = input.int(1, "左侧K线数 (Left Bars)", minval=1, group="Standard Logic")
rightBars = input.int(1, "右侧K线数 (Right Bars)", minval=1, group="Standard Logic")

// step 4.1: 标准分型检测 (Standard Pivot Detection)
// --------------------------------------------------------------------------
ph = ta.pivothigh(high, leftBars, rightBars)
pl = ta.pivotlow(low, leftBars, rightBars)

// Stroke Generation State
var int lastPivotIdx = na
var float lastPivotPx = na
var int lastPivotDir = 0 // 1: High, -1: Low

bool newStrokeAdded = false
var line liveStroke = line.new(na, na, na, na)

// step 4.2: 笔生成逻辑 (Stroke Generation Logic)
// --------------------------------------------------------------------------
if not na(ph)
    // Found a High Pivot
    int idx = bar_index[rightBars]
    float px = ph
    
    if lastPivotDir == -1 // Last was Low, now High -> Up Stroke
        // Check validity (simple check)
        if idx > lastPivotIdx
            // Create Up Stroke
            s = Stroke.new(lastPivotIdx, lastPivotPx, idx, px, 1, 0, line(na))
            strokes.push(s)
            strictStrokes.push(s)
            newStrokeAdded := true
            
            // Update State
            lastPivotIdx := idx
            lastPivotPx := px
            lastPivotDir := 1
            
            // Draw
            if showStrokeLines
                s.l := gc.drawLine(s.startIdx, s.startPx, s.endIdx, s.endPx, xloc.bar_index, col_stroke_up, 2)

    else if lastPivotDir == 1 // Last was High, found new High
        // Update High if higher
        if px > lastPivotPx
            // Extend the current Up Stroke
            if strokes.size() > 0
                lastS = strokes.get(strokes.size() - 1)
                // Update End Point
                lastS.endIdx := idx
                lastS.endPx := px
                
                // Update State
                lastPivotIdx := idx
                lastPivotPx := px
                
                // Redraw
                if showStrokeLines
                    line.delete(lastS.l)
                    lastS.l := gc.drawLine(lastS.startIdx, lastS.startPx, lastS.endIdx, lastS.endPx, xloc.bar_index, col_stroke_up, 2)
            
    else if lastPivotDir == 0 // Init
        lastPivotIdx := idx
        lastPivotPx := px
        lastPivotDir := 1

if not na(pl)
    // Found a Low Pivot
    int idx = bar_index[rightBars]
    float px = pl
    
    if lastPivotDir == 1 // Last was High, now Low -> Down Stroke
        // Check validity
        if idx > lastPivotIdx
            // Create Down Stroke
            s = Stroke.new(lastPivotIdx, lastPivotPx, idx, px, -1, 0, line(na))
            strokes.push(s)
            // strictStrokes.push(s) // Avoid reference sharing if not needed
            newStrokeAdded := true
            
            // Update State
            lastPivotIdx := idx
            lastPivotPx := px
            lastPivotDir := dir
            
            // Draw
            if showStrokeLines
                s.l := gc.drawLine(s.startIdx, s.startPx, s.endIdx, s.endPx, xloc.bar_index, col_stroke_dn, 2)

    else if lastPivotDir == -1 // Last was Low, found new Low
        if px < lastPivotPx
            // Extend the current Down Stroke
            if strokes.size() > 0
                lastS = strokes.get(strokes.size() - 1)
                lastS.endIdx := idx
                lastS.endPx := px
                
                lastPivotIdx := idx
                lastPivotPx := px
                
                if showStrokeLines
                    line.delete(lastS.l)
                    lastS.l := gc.drawLine(lastS.startIdx, lastS.startPx, lastS.endIdx, lastS.endPx, xloc.bar_index, col_stroke_dn, 2)
    
    else if lastPivotDir == 0 // Init
        lastPivotIdx := idx
        lastPivotPx := px
        lastPivotDir := -1

// ==========================================================================
// STEP 05: 中枢与线段 (Centers & Segments)
// ==========================================================================

var centers = array.new<CenterState>()
var int lastCenterEndIdx = -1 // Track the last stroke index of the previous center
if newStrokeAdded
    // step 5.1: 中枢更新 (Center Update)
    // ----------------------------------------------------------------------
    int cStatus = centerSt.update(strokes, lastCenterEndIdx)
    
    // Draw Center Box
    if centerSt.inCenter
        if showCenter
            sStart = strokes.get(centerSt.startStr)
            sEnd = strokes.get(centerSt.lastStr)
            txt = showCenterLabels ? "ZG:" + str.tostring(centerSt.zg, "#.##") + "\nZD:" + str.tostring(centerSt.zd, "#.##") : ""
            gc.drawBox(sStart.startIdx, centerSt.zg, sEnd.endIdx, centerSt.zd, xloc.bar_index, color.new(col_center_bg, 50), col_center_bg, txt, col_text)
    
    if cStatus == 3 // Finished
        centers.push(centerSt.copy())
        lastCenterEndIdx := centerSt.lastStr // Update exclusion index

    // step 5.2: 线段更新 (Segment Update)
    // ----------------------------------------------------------------------
    bool segFinished = segSt.update(strokes, minStrokesPerSeg)

    if segFinished and showSegLines
        sPrev = strokes.get(segSt.oldStartStr)
        sCurr = strokes.get(segSt.startStr)
        
        int x1 = na
        float y1 = na
        int x2 = na
        float y2 = na
        
        if segSt.dir == -1 // Finished segment was UP (now turned Down)
            // Start: Low of sPrev
            x1 := sPrev.dir == 1 ? sPrev.startIdx : sPrev.endIdx
            y1 := math.min(sPrev.startPx, sPrev.endPx)
            // End: High of sCurr
            x2 := sCurr.dir == 1 ? sCurr.endIdx : sCurr.startIdx
            y2 := math.max(sCurr.startPx, sCurr.endPx)
            gc.drawLine(x1, y1, x2, y2, xloc.bar_index, col_seg_up, segLineWidth)
        else // Finished segment was DOWN (now turned Up)
            // Start: High of sPrev
            x1 := sPrev.dir == 1 ? sPrev.endIdx : sPrev.startIdx
            y1 := math.max(sPrev.startPx, sPrev.endPx)
            // End: Low of sCurr
            x2 := sCurr.dir == 1 ? sCurr.startIdx : sCurr.endIdx
            y2 := math.min(sCurr.startPx, sCurr.endPx)
            gc.drawLine(x1, y1, x2, y2, xloc.bar_index, col_seg_dn, segLineWidth)

    // step 5.3: 实时线段绘制 (Live Segment Drawing)
    // ----------------------------------------------------------------------
    var line liveSeg = line.new(na, na, na, na, width=segLineWidth)
    if showSegLines and segSt.inProgress
        sStart = strokes.get(segSt.startStr)
        sEnd = strokes.get(segSt.lastStr)
        
        int lx1 = na
        float ly1 = na
        int lx2 = na
        float ly2 = na
        
        if segSt.dir == 1 // Current is UP
            // Start: Low of sStart
            lx1 := sStart.dir == 1 ? sStart.startIdx : sStart.endIdx
            ly1 := math.min(sStart.startPx, sStart.endPx)
            // End: High of sEnd
            lx2 := sEnd.dir == 1 ? sEnd.endIdx : sEnd.startIdx
            ly2 := math.max(sEnd.startPx, sEnd.endPx)
            
            line.set_color(liveSeg, col_seg_up)
        else // Current is DOWN
            // Start: High of sStart
            lx1 := sStart.dir == 1 ? sStart.endIdx : sStart.startIdx
            ly1 := math.max(sStart.startPx, sStart.endPx)
            // End: Low of sEnd
            lx2 := sEnd.dir == 1 ? sEnd.startIdx : sEnd.endIdx
            ly2 := math.min(sEnd.startPx, sEnd.endPx)
            
            line.set_color(liveSeg, col_seg_dn)
            
        line.set_xy1(liveSeg, lx1, ly1)
        line.set_xy2(liveSeg, lx2, ly2)
    else
        line.set_xy1(liveSeg, na, na)
        line.set_xy2(liveSeg, na, na)

// ==========================================================================
// STEP 06: 信号生成 (Signal Generation)
// ==========================================================================
var bool c1Buy = false
var bool c1Sell = false
var float c1BuyPx = na
var float c1SellPx = na
var bool c2BuyTrig = false
var bool c2SellTrig = false
var bool c3Buy = false
var bool c3Sell = false

if strokes.size() >= 2 and newStrokeAdded
    curS = strokes.get(strokes.size() - 1)
    
    // step 6.1: C1 趋势背驰 (Trend Divergence)
    // ----------------------------------------------------------------------
    // Logic: New Low + MACD Divergence + Gaussian Filter
    if curS.dir == -1
        l0 = curS.get_low()
        // Check Divergence
        isDiv = false
        // Simple Stroke Divergence
        if strokes.size() >= 3
            prevDownS = strokes.get(strokes.size() - 3)
            if l0 < prevDownS.get_low() and curS.macdHist > prevDownS.macdHist
                isDiv := true
        
        // Gaussian Filter
        isGauss = not use_gaussian_filter or (l0 <= get_val_at_bar(lower_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Buy := true
            c1BuyPx := l0
            c2BuyTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, l0, "C1 Buy", col_label_buy, label.style_label_up, col_text)

    // Sell: Up Stroke, New High, MACD Divergence, Gaussian Filter
    if curS.dir == 1
        h0 = curS.get_high()
        isDiv = false
        if strokes.size() >= 3
            prevUpS = strokes.get(strokes.size() - 3)
            if h0 > prevUpS.get_high() and curS.macdHist < prevUpS.macdHist
                isDiv := true
        
        isGauss = not use_gaussian_filter or (h0 >= get_val_at_bar(upper_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Sell := true
            c1SellPx := h0
            c2SellTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, h0, "C1 Sell", col_label_sell, label.style_label_down, col_text)

// step 6.2: C2 次级别确认 (Second Confirmation)
// --------------------------------------------------------------------------
if c1Buy and not c2BuyTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    // Wait for a Down stroke that doesn't break C1 Low
    if lastS.dir == -1
        if lastS.get_low() > c1BuyPx
            c2BuyTrig := true
            c1Buy := false // Reset C1 state
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Buy", col_label_buy, label.style_label_up, col_text)

if c1Sell and not c2SellTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    if lastS.dir == 1
        if lastS.get_high() < c1SellPx
            c2SellTrig := true
            c1Sell := false
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Sell", col_label_sell, label.style_label_down, col_text)

// step 6.3: C3 趋势爆发 (Trend Explosion)
// --------------------------------------------------------------------------
if strokes.size() > 0 and centers.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    lastC = centers.get(centers.size() - 1)
    
    // C3 Buy: Rising Center (ori=1) + Pullback Low >= ZG
    if lastC.ori == 1
        // We need a pullback (Down stroke)
        if lastS.dir == -1
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                if lastS.get_low() > lastC.zg
                    c3Buy := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Buy", col_label_buy, label.style_label_up, col_text)

    // C3 Sell: Falling Center (ori=-1) + Pullback High <= ZD
    if lastC.ori == -1
        // We need a pullback (Up stroke)
        if lastS.dir == 1
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                if lastS.get_high() < lastC.zd
                    c3Sell := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Sell", col_label_sell, label.style_label_down, col_text)

// ==========================================================================
// STEP 07: 交易执行 (Execution)
// ==========================================================================
// Global Execution Variables
var float g_long_entry = na
var float g_long_sl    = na
var int   g_long_stage = 0 
var float g_short_entry = na
var float g_short_sl    = na
var int   g_short_stage = 0

// step 7.1: 执行辅助函数 (Execution Helpers)
// --------------------------------------------------------------------------
do_buy(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size <= 0
        float riskPerShare = close - _sl
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_l = riskAmount / riskPerShare
            strategy.entry("Long", strategy.long, qty=qty_l, comment=_id)
            strategy.exit("L_TP1", from_entry="Long", qty_percent=33.3, limit=close + riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=close + 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

do_sell(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size >= 0
        float riskPerShare = _sl - close
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_s = riskAmount / riskPerShare
            strategy.entry("Short", strategy.short, qty=qty_s, comment=_id)
            strategy.exit("S_TP1", from_entry="Short", qty_percent=33.3, limit=close - riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=close - 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

// step 7.2: 信号触发 (Signal Trigger)
// --------------------------------------------------------------------------
bool stroke_updated = newStrokeAdded

if useC1ForEntry and stroke_updated
    if c1Buy
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C1", c1BuyPx, risk_per_trade)
            g_long_entry := close
            g_long_sl := c1BuyPx
            g_long_stage := 0
        c1Buy := false // Reset flag

    if c1Sell
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C1", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c1Sell := false

if stroke_updated
    if c2BuyTrig
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C2", c1BuyPx, risk_per_trade)
            g_long_entry := close, g_long_sl := c1BuyPx, g_long_stage := 0
        c2BuyTrig := false

    if c2SellTrig
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C2", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c2SellTrig := false

    if c3Buy
        float sl_val = not na(centerSt.zg) ? centerSt.zg : c1BuyPx
        float lastZG = na
        if centers.size() > 0
            lastZG := centers.get(centers.size()-1).zg
        
        float final_sl = not na(lastZG) ? lastZG : c1BuyPx
        
        if do_buy("Long_C3", final_sl, risk_per_trade)
            g_long_entry := close
            g_long_sl := final_sl
            g_long_stage := 0
        c3Buy := false

    if c3Sell
        float lastZD = na
        if centers.size() > 0
            lastZD := centers.get(centers.size()-1).zd
        
        float final_sl_s = not na(lastZD) ? lastZD : c1SellPx
        
        if do_sell("Short_C3", final_sl_s, risk_per_trade)
            g_short_entry := close, g_short_sl := final_sl_s
            g_short_stage := 0
        c3Sell := false

// step 7.3: 动态止盈止损 (Dynamic SL/TP)
// --------------------------------------------------------------------------
if strategy.position_size > 0 and not na(g_long_entry) and not na(g_long_sl)
    risk = g_long_entry - g_long_sl
    if high >= (g_long_entry + risk) and g_long_stage < 1
        g_long_stage := 1
        strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=g_long_entry + 2*risk, stop=g_long_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry, comment_profit="Run", comment_loss="SL_BE")
    if high >= (g_long_entry + 2*risk) and g_long_stage < 2
        g_long_stage := 2
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry + risk, comment_profit="Run", comment_loss="SL_1R")

if strategy.position_size < 0 and not na(g_short_entry) and not na(g_short_sl)
    risk = g_short_sl - g_short_entry
    if low <= (g_short_entry - risk) and g_short_stage < 1
        g_short_stage := 1
        strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=g_short_entry - 2*risk, stop=g_short_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry, comment_profit="Run", comment_loss="SL_BE")
    if low <= (g_short_entry - 2*risk) and g_short_stage < 2
        g_short_stage := 2
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry - risk, comment_profit="Run", comment_loss="SL_1R")

// Manual Aux Lines
man_Enable = input.bool(false, "启用手动辅助线", group=grpMoney)
man_EntryPrice_str = input.string("", "手动入场价", group=grpMoney)
man_EntryPrice_val = str.length(man_EntryPrice_str) == 0 ? na : str.tonumber(man_EntryPrice_str)

if man_Enable and not na(man_EntryPrice_val)
    line.new(bar_index, man_EntryPrice_val, bar_index+10, man_EntryPrice_val, color=color.white, width=2)
