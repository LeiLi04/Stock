//@version=6
library("ChanLunLib", overlay=true)

// ==============================
// Core ChanLun Logic
// ==============================

export type Stroke
    int startIdx
    float startPx
    int endIdx
    float endPx
    int dir // 1: Up, -1: Down
    float macdHist // MACD at end

export type CenterState
    bool inCenter
    float zg
    float zd
    int startStr
    int lastStr
    int enterDir
    int exitDir
    int ori // 1: Up, -1: Down, 0: Invalid

export method copy(CenterState this) =>
    CenterState.new(this.inCenter, this.zg, this.zd, this.startStr, this.lastStr, this.enterDir, this.exitDir, this.ori)

export type SegState
    bool inProgress
    int startStr
    int lastStr
    int dir
    float fHigh
    float fLow
    int peakStr
    int lastEndBar
    float lastEndPx
    int strokeCnt

// Helper to get value at specific bar index
export get_val_at_bar(float src, int idx) =>
    ta.valuewhen(bar_index == idx, src, 0)

// Stroke Logic
export method update(array<Stroke> strokes, bool hasPivot, bool isHigh, int idx, float price, int minBars)
    bool newStroke = false
    if hasPivot
        // Check if we have any strokes yet
        if strokes.size() == 0
            // Initialize first point (virtual) - waiting for second point to form a stroke
            // Actually, we need a previous pivot to form a stroke. 
            // This logic needs to be stateful. 
            // Let's adapt the logic from main.pine.
            na
        else
            lastS = strokes.get(strokes.size() - 1)
            // Logic adaptation required: The original code tracked lastPivotIndex/Price separately.
            // We will assume the caller manages the raw pivots and calls this when a potential stroke forms.
            na
    newStroke

// Simplified Stroke Creator (Caller tracks last pivot)
export createStroke(int lpIdx, float lpPx, int idx, float price, int dir, float hist) =>
    Stroke.new(lpIdx, lpPx, idx, price, dir, hist)

export method get_high(Stroke this) =>
    math.max(this.startPx, this.endPx)

export method get_low(Stroke this) =>
    math.min(this.startPx, this.endPx)

// Center Logic
export method update(CenterState st, array<Stroke> strokes, int lastCenterEndIdx)
    int status = 0 // 0: Nothing, 1: New, 2: Extension, 3: Finished
    sz = strokes.size()
    if sz >= 3
        if not st.inCenter
            // Ensure new center starts AFTER the last finished center
            // The first stroke of the new center is s2 (sz-3).
            // So (sz-3) must be > lastCenterEndIdx.
            if (sz - 3) > lastCenterEndIdx
            s0 = strokes.get(sz - 1)
            s1 = strokes.get(sz - 2)
            s2 = strokes.get(sz - 3)
            
            // 1. Price Overlap
            hi = math.min(math.max(s2.startPx, s2.endPx), math.min(math.max(s1.startPx, s1.endPx), math.max(s0.startPx, s0.endPx)))
            lo = math.max(math.min(s2.startPx, s2.endPx), math.max(math.min(s1.startPx, s1.endPx), math.min(s0.startPx, s0.endPx)))
            
            // 2. Direction
            d0 = s0.dir
            d1 = s1.dir
            d2 = s2.dir
            
            // Enter Direction (from previous stroke)
            enterD = 0
            if sz >= 4
                enterD := strokes.get(sz - 4).dir
            
            // 3. Strict Pattern
            bool isDownCenter = (enterD == -1) and (d2 == 1) and (d1 == -1) and (d0 == 1)
            bool isUpCenter   = (enterD == 1)  and (d2 == -1) and (d1 == 1)  and (d0 == -1)
            
            if (isDownCenter or isUpCenter) and (hi >= lo)
                st.zg := hi
                st.zd := lo
                st.inCenter := true
                st.startStr := sz - 3
                st.lastStr := sz - 1
                st.enterDir := enterD
                st.ori := 0
                status := 1
        else
            // Extension
            s = strokes.get(sz - 1)
            hi2 = math.max(s.startPx, s.endPx)
            lo2 = math.min(s.startPx, s.endPx)
            newZG = math.min(st.zg, hi2)
            newZD = math.max(st.zd, lo2)
            
            if newZG >= newZD
                st.zg := newZG
                st.zd := newZD
                st.lastStr := sz - 1
                status := 2
            else
                // Break
                st.exitDir := s.dir
                if st.exitDir == st.enterDir
                    st.ori := st.exitDir
                else
                    st.ori := 0
                st.inCenter := false
                status := 3
    status

// Segment Logic
export method update(SegState st, array<Stroke> strokes, int minStrokes)
    didFinalize = false
    sz = strokes.size()
    if sz > 0
        newStrIdx = sz - 1
        s = strokes.get(newStrIdx)
        
        if not st.inProgress and sz >= 3
            // Initialize Segment
            i0 = sz - 1, i2 = sz - 3
            s0 = strokes.get(i0), s2 = strokes.get(i2)
            
            // Determine direction based on High/Low of strokes
            // If Up Segment, we expect Higher Highs? 
            // Standard ChanLun: Segment starts from a feature sequence.
            // Simplified here: Direction based on end prices of strokes
            dirCand = s0.endPx > s2.endPx ? 1 : -1
            
            st.dir := dirCand
            st.startStr := i2
            st.lastStr := i0
            st.peakStr := i0
            st.strokeCnt := 3
            
            if st.dir > 0
                // Up Segment: Peak is the Highest High
                st.peakStr := math.max(s2.startPx, s2.endPx) > math.max(s0.startPx, s0.endPx) ? i2 : i0
                st.fLow := math.min(s0.startPx, s0.endPx)
            else
                // Down Segment: Peak is the Lowest Low
                st.peakStr := math.min(s2.startPx, s2.endPx) < math.min(s0.startPx, s0.endPx) ? i2 : i0
                st.fHigh := math.max(s0.startPx, s0.endPx)
            
            st.inProgress := true
            
        else if st.inProgress
            // Continue Segment
            if s.dir == st.dir
                st.lastStr := newStrIdx
                st.strokeCnt += 1
                if st.dir > 0
                    // Up Segment: Check for new High
                    sHi = math.max(s.startPx, s.endPx)
                    peakHi = math.max(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sHi >= peakHi
                        st.peakStr := newStrIdx
                    st.fLow := math.min(s.startPx, s.endPx)
                else
                    // Down Segment: Check for new Low
                    sLo = math.min(s.startPx, s.endPx)
                    peakLo = math.min(strokes.get(st.peakStr).startPx, strokes.get(st.peakStr).endPx)
                    if sLo <= peakLo
                        st.peakStr := newStrIdx
                    st.fHigh := math.max(s.startPx, s.endPx)
            else
                // Counter Stroke
                st.strokeCnt += 1
                broke = false
                if st.dir > 0
                    if math.min(s.startPx, s.endPx) < st.fLow
                        broke := true
                else
                    if math.max(s.startPx, s.endPx) > st.fHigh
                        broke := true
                
                if broke
                    if st.strokeCnt >= minStrokes
                        // Finalize Segment
                        didFinalize := true
                        // New Segment starts from Peak
                        st.startStr := st.peakStr
                        st.lastStr := newStrIdx
                        st.dir := -st.dir
                        st.peakStr := newStrIdx
                        st.strokeCnt := 1
                        st.fHigh := math.max(s.startPx, s.endPx)
                        st.fLow := math.min(s.startPx, s.endPx)
                    else
                        // Noise (Sub-segment correction)
                        st.lastStr := newStrIdx
                        if st.dir > 0
                            st.fLow := math.min(st.fLow, math.min(s.startPx, s.endPx))
                        else
                            st.fHigh := math.max(st.fHigh, math.max(s.startPx, s.endPx))
    didFinalize
