//@version=6
indicator("ChanLun Pro Strict v15", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500)

"""
Algorithm Summary:
    A professional-grade implementation of ChanLun (Zen/Entanglement Theory) for market analysis.
    Integrates Fractal Geometry (FenXing), Stroke (Bi), Segment (XianDuan), and Center (ZhongShu) 
    structures to identify high-probability trend reversals and continuations.

Symbol Legend:
    K : Raw Candlestick Data {Open, High, Low, Close}
    K': Normalized Candlestick (after Inclusion Processing)
    S : Stroke Sequence {s_0, s_1, ...}
    C : Center State {ZG, ZD, ...}
    L : Signal Logic (C1, C2, C3)

    Core Tensor Flow:
    Raw OHLC -> [Inclusion] -> Normalized K -> [Fractal] -> Pivots -> [Stroke Gen] -> Strokes -> [Center Gen] -> Centers -> [Signal] -> Trade
"""

import ./libraries/ChanLunLib as cl
import ./libraries/DrawingLib as dl

// ==========================================================================
// STEP 01: 参数配置 (Configuration & Hyperparameters)
// ==========================================================================
grpA = "1. 缠论结构 (Structure)"
lrb = input.int(1, "分型左右K数", minval=1, group=grpA)
minBarsStroke = input.int(4, "成笔最小跨度", minval=1, group=grpA)
useNorm = input.bool(true, "启用K线包含处理", group=grpA)
minStrokesPerSeg = input.int(3, "线段最少包含笔数", minval=3, group=grpA)

grpDisp = "2. 显示开关 (Display)"
showInclusion   = input.bool(false, "显示包含处理K线", group=grpDisp)
showStrokeLines = input.bool(true,  "显示 笔 (Strokes)", group=grpDisp)
showSegLines    = input.bool(true,  "显示 线段 (Segments)", group=grpDisp)
segLineWidth    = input.int(2,      "线段线宽", minval=1, maxval=10, group=grpDisp)
showCenter      = input.bool(true,  "显示 中枢 (Centers)", group=grpDisp)
showCenterLabels= input.bool(true,  "显示 中枢数值", group=grpDisp)
showSignalLabels= input.bool(true,  "显示 信号标签", group=grpDisp)

grpEnh = "4. 信号过滤"
use_gaussian_filter = input.bool(true, "启用高斯通道过滤 (C1)", group=grpEnh)
gauss_len = input.int(20, "高斯周期", group=grpEnh)
gauss_mult = input.float(2.0, "高斯带宽", step=0.1, group=grpEnh)
show_gaussian_bands = input.bool(false, "显示高斯通道", group=grpEnh)
macd_use_segment = input.bool(true, "C1 使用线段级背驰", group=grpEnh)

grpCol = "5. 颜色风格"
col_stroke_up = input.color(color.lime, "上涨笔", group=grpCol)
col_stroke_dn = input.color(color.red, "下跌笔", group=grpCol)
col_seg_up    = input.color(color.blue, "上涨线段", group=grpCol)
col_seg_dn    = input.color(color.blue, "下跌线段", group=grpCol)
col_center_bg = input.color(color.new(color.orange, 80), "中枢填充", group=grpCol)
col_text      = input.color(color.white, "文字颜色", group=grpCol)
col_label_buy = input.color(color.lime, "买点颜色", group=grpCol)
col_label_sell= input.color(color.red, "卖点颜色", group=grpCol)

grpInd = "3. 辅助指标"
showMA   = input.bool(false, "启用均线系统", group=grpInd)
ma1_len  = input.int(5, "MA 1", group=grpInd, inline="ma1")
show_ma1 = input.bool(true, "", group=grpInd, inline="ma1")
ma2_len  = input.int(10, "MA 2", group=grpInd, inline="ma2")
show_ma2 = input.bool(true, "", group=grpInd, inline="ma2")
ma3_len  = input.int(20, "MA 3", group=grpInd, inline="ma3")
show_ma3 = input.bool(true, "", group=grpInd, inline="ma3")
ma4_len  = input.int(30, "MA 4", group=grpInd, inline="ma4")
show_ma4 = input.bool(true, "", group=grpInd, inline="ma4")
ma5_len  = input.int(60, "MA 5", group=grpInd, inline="ma5")
show_ma5 = input.bool(true, "", group=grpInd, inline="ma5")

showBB   = input.bool(false, "启用布林带", group=grpInd)
bb_len   = input.int(20, "布林周期", group=grpInd)
bb_mult  = input.float(2.0, "布林带宽", group=grpInd)

useNeonCandles = input.bool(false, "强制覆盖K线颜色", group=grpCol)
col_candle_up = input.color(color.lime, "涨K线", group=grpCol)
col_candle_dn = input.color(color.red, "跌K线", group=grpCol)

// ==========================================================================
// STEP 02: 系统初始化 (System Initialization)
// ==========================================================================
var gc = dl.GCManager.new()
if barstate.isfirst
    gc.init(400)

var strokes = array.new<cl.Stroke>()
var centerSt = cl.CenterState.new(false, na, na, na, na, 0, 0, 0)
var segSt = cl.SegState.new(false, na, na, 0, na, na, na, na, na, 0)

// ==========================================================================
// STEP 03: 数据预处理 (Data Preprocessing)
// ==========================================================================

// step 3.1: 基础指标计算 (Basic Indicators)
// --------------------------------------------------------------------------
[macd, signal, hist] = ta.macd(close, 12, 26, 9)

// step 3.2: 高斯通道 (Gaussian Channel)
// --------------------------------------------------------------------------
// Why: Used for volatility-based filtering of signals.
// Math: Upper = EMA(Close) + k * EMA(TR)
basis = ta.ema(close, gauss_len)
volatility = ta.ema(ta.tr(true), gauss_len)
upper_bound = basis + (gauss_mult * volatility)
lower_bound = basis - (gauss_mult * volatility)
if show_gaussian_bands
    p1 = plot(upper_bound, "Upper", color=color.red)
    p2 = plot(lower_bound, "Lower", color=color.green)
    fill(p1, p2, color=color.new(color.gray, 95))

// step 3.3: 均线与布林带 (MA & BB)
// --------------------------------------------------------------------------
plot(showMA and show_ma1 ? ta.sma(close, ma1_len) : na, "MA1", color=color.yellow)
plot(showMA and show_ma2 ? ta.sma(close, ma2_len) : na, "MA2", color=color.white)
plot(showMA and show_ma3 ? ta.sma(close, ma3_len) : na, "MA3", color=color.aqua)
plot(showMA and show_ma4 ? ta.sma(close, ma4_len) : na, "MA4", color=color.orange)
plot(showMA and show_ma5 ? ta.sma(close, ma5_len) : na, "MA5", color=color.red, linewidth=2)

[bb_mid, bb_upper, bb_lower] = ta.bb(close, bb_len, bb_mult)
plot(showBB ? bb_upper : na, "BB Upper", color=color.new(color.blue, 80))
plot(showBB ? bb_lower : na, "BB Lower", color=color.new(color.blue, 80))
plot(showBB ? bb_mid : na, "BB Mid", color=color.new(color.orange, 80))

// Neon Candles
barcolor(useNeonCandles ? (close >= open ? col_candle_up : col_candle_dn) : na)

// step 3.4: K线包含处理 (K-Line Inclusion)
// --------------------------------------------------------------------------
// Why: Remove noise by merging contained bars.
// Math:
//   If Up Trend: High' = max(H1, H2), Low' = max(L1, L2)
//   If Down Trend: High' = min(H1, H2), Low' = min(L1, L2)
var float nHigh = na, var float nLow = na, var int nDir = 0
if na(nHigh)
    nHigh := high, nLow := low, nDir := close >= open ? 1 : -1
else
    contain_prev = high <= nz(nHigh[1]) and low >= nz(nLow[1])
    contain_rev = high[1] <= high and low[1] >= low
    _ndir = nDir != 0 ? nDir : (close >= close[1] ? 1 : -1)
    if useNorm and (contain_prev or contain_rev)
        if _ndir >= 0 
            nHigh := math.max(nz(nHigh[1], high), high)
            nLow := math.max(nz(nLow[1], low), low)
        else          
            nHigh := math.min(nz(nHigh[1], high), high)
            nLow := math.min(nz(nLow[1], low), low)
    else
        nHigh := high, nLow := low, nDir := close >= close[1] ? 1 : -1

plot(showInclusion ? nHigh : na, color=color.new(color.aqua, 50), title="NormHigh")
plot(showInclusion ? nLow : na, color=color.new(color.fuchsia, 50), title="NormLow")

// ==========================================================================
// STEP 04: 笔生成 (Stroke Generation)
// ==========================================================================

// step 4.1: 分型识别 (Fractal Detection)
// --------------------------------------------------------------------------
srcH = useNorm ? nHigh : high
srcL = useNorm ? nLow : low
ph = ta.pivothigh(srcH, lrb, lrb)
pl = ta.pivotlow(srcL, lrb, lrb)

var int lastPivotIndex = na
var float lastPivotPrice = na
var int lastPivotType = 0 // 0:None, 1:High, 2:Low

// step 4.2: 笔构造函数 (Stroke Constructor)
// --------------------------------------------------------------------------
makeStroke(_hasPivot, _isHigh, _idx, _price) =>
    bool created = false
    int curType = _isHigh ? 1 : 2
    
    if not na(lastPivotIndex) and lastPivotType != 0 and curType != lastPivotType
        distBars = _idx - lastPivotIndex
        if distBars >= minBarsStroke
            // Valid Stroke
            dir = _isHigh ? 1 : -1
            histVal = cl.get_val_at_bar(hist, _idx)
            
            s = cl.createStroke(lastPivotIndex, lastPivotPrice, _idx, _price, dir, histVal)
            strokes.push(s)
            
            if showStrokeLines
                gc.drawLine(lastPivotIndex, lastPivotPrice, _idx, _price, xloc.bar_index, dir>0?col_stroke_up:col_stroke_dn, 2)
            
            created := true
            lastPivotIndex := _idx
            lastPivotPrice := _price
            lastPivotType := curType
    else if na(lastPivotIndex) or lastPivotType == 0
        // First Pivot
        lastPivotIndex := _idx
        lastPivotPrice := _price
        lastPivotType := curType
    else
        // Extension (Update Pivot if better)
        if (_isHigh and _price > lastPivotPrice) or (not _isHigh and _price < lastPivotPrice)
            lastPivotIndex := _idx
            lastPivotPrice := _price

    created

// step 4.3: 分型处理逻辑 (Pivot Processing)
// --------------------------------------------------------------------------
bool evPH = not na(ph)
bool evPL = not na(pl)
int phIdx = evPH ? bar_index - lrb : na
int plIdx = evPL ? bar_index - lrb : na

if evPH and evPL
    if lastPivotType == 2 // Last was Low, expect High
        evPL := false
    else if lastPivotType == 1
        evPH := false

bool madePH = false
bool madePL = false

if evPH
    madePH := makeStroke(true, true, phIdx, ph)
if evPL
    madePL := makeStroke(true, false, plIdx, pl)

var centers = array.new<cl.CenterState>()

// ==========================================================================
// STEP 05: 中枢与线段 (Centers & Segments)
// ==========================================================================
if madePH or madePL
    // step 5.1: 中枢更新 (Center Update)
    // ----------------------------------------------------------------------
    int cStatus = centerSt.update(strokes, -1) // Note: lastCenterEndIdx not tracked here in main.pine simplified logic
    
    // Draw Center Box
    if centerSt.inCenter
        if showCenter
            sStart = strokes.get(centerSt.startStr)
            sEnd = strokes.get(centerSt.lastStr)
            txt = showCenterLabels ? "ZG:" + str.tostring(centerSt.zg, "#.##") + "\nZD:" + str.tostring(centerSt.zd, "#.##") : ""
            gc.drawBox(sStart.startIdx, centerSt.zg, sEnd.endIdx, centerSt.zd, xloc.bar_index, color.new(col_center_bg, 50), col_center_bg, txt, col_text)
    
    if cStatus == 3 // Finished
        centers.push(centerSt.copy())

    // step 5.2: 线段更新 (Segment Update)
    // ----------------------------------------------------------------------
    if segSt.update(strokes, minStrokesPerSeg)
        na

    // step 5.3: 实时线段绘制 (Live Segment Drawing)
    // ----------------------------------------------------------------------
    var line liveSeg = line.new(na, na, na, na, width=segLineWidth)
    if showSegLines and segSt.inProgress
        sStart = strokes.get(segSt.startStr)
        sEnd = strokes.get(segSt.lastStr) // Connect to latest stroke tip
        
        line.set_xy1(liveSeg, sStart.endIdx, sStart.endPx) // Approx start
        line.set_xy1(liveSeg, sStart.startIdx, sStart.startPx)
        line.set_xy2(liveSeg, sEnd.endIdx, sEnd.endPx)
        line.set_color(liveSeg, segSt.dir > 0 ? col_seg_up : col_seg_dn)
    else
        line.set_xy1(liveSeg, na, na)
        line.set_xy2(liveSeg, na, na)

// ==========================================================================
// STEP 06: 信号生成 (Signal Generation)
// ==========================================================================
var bool c1Buy = false
var bool c1Sell = false
var float c1BuyPx = na
var float c1SellPx = na
var bool c2BuyTrig = false
var bool c2SellTrig = false
var bool c3Buy = false
var bool c3Sell = false

if strokes.size() >= 2 and (madePH or madePL)
    curS = strokes.get(strokes.size() - 1)
    
    // step 6.1: C1 趋势背驰 (Trend Divergence)
    // ----------------------------------------------------------------------
    // Logic: New Low + MACD Divergence + Gaussian Filter
    if curS.dir == -1
        l0 = curS.get_low()
        // Check Divergence
        isDiv = false
        if strokes.size() >= 3
            prevDownS = strokes.get(strokes.size() - 3)
            if l0 < prevDownS.get_low() and curS.macdHist > prevDownS.macdHist
                isDiv := true
        
        // Gaussian Filter
        isGauss = not use_gaussian_filter or (l0 <= cl.get_val_at_bar(lower_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Buy := true
            c1BuyPx := l0
            c2BuyTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, l0, "C1 Buy", col_label_buy, label.style_label_up, col_text)

    // Sell Logic
    if curS.dir == 1
        h0 = curS.get_high()
        isDiv = false
        if strokes.size() >= 3
            prevUpS = strokes.get(strokes.size() - 3)
            if h0 > prevUpS.get_high() and curS.macdHist < prevUpS.macdHist
                isDiv := true
        
        isGauss = not use_gaussian_filter or (h0 >= cl.get_val_at_bar(upper_bound, curS.endIdx))
        
        if isDiv and isGauss
            c1Sell := true
            c1SellPx := h0
            c2SellTrig := false
            if showSignalLabels
                gc.drawLabel(curS.endIdx, h0, "C1 Sell", col_label_sell, label.style_label_down, col_text)

// step 6.2: C2 次级别确认 (Second Confirmation)
// --------------------------------------------------------------------------
if c1Buy and not c2BuyTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    // Wait for a Down stroke that doesn't break C1 Low
    if lastS.dir == -1
        if lastS.get_low() > c1BuyPx
            c2BuyTrig := true
            c1Buy := false // Reset C1 state
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Buy", col_label_buy, label.style_label_up, col_text)

if c1Sell and not c2SellTrig and strokes.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    if lastS.dir == 1
        if lastS.get_high() < c1SellPx
            c2SellTrig := true
            c1Sell := false
            if showSignalLabels
                gc.drawLabel(lastS.endIdx, lastS.endPx, "C2 Sell", col_label_sell, label.style_label_down, col_text)

// step 6.3: C3 趋势爆发 (Trend Explosion)
// --------------------------------------------------------------------------
if strokes.size() > 0 and centers.size() > 0
    lastS = strokes.get(strokes.size() - 1)
    lastC = centers.get(centers.size() - 1)
    
    // C3 Buy: Rising Center (ori=1) + Pullback Low >= ZG
    if lastC.ori == 1
        if lastS.dir == -1
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                if lastS.get_low() > lastC.zg
                    c3Buy := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Buy", col_label_buy, label.style_label_up, col_text)

    // C3 Sell: Falling Center (ori=-1) + Pullback High <= ZD
    if lastC.ori == -1
        if lastS.dir == 1
            if (strokes.size() - 1) == (lastC.lastStr + 2)
                if lastS.get_high() < lastC.zd
                    c3Sell := true
                    if showSignalLabels
                        gc.drawLabel(lastS.endIdx, lastS.endPx, "C3 Sell", col_label_sell, label.style_label_down, col_text)

// ==========================================================================
// STEP 07: 交易执行 (Execution)
// ==========================================================================
// Global Execution Variables
var float g_long_entry = na
var float g_long_sl    = na
var int   g_long_stage = 0 
var float g_short_entry = na
var float g_short_sl    = na
var int   g_short_stage = 0

// step 7.1: 执行辅助函数 (Execution Helpers)
// --------------------------------------------------------------------------
do_buy(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size <= 0
        float riskPerShare = close - _sl
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_l = riskAmount / riskPerShare
            strategy.entry("Long", strategy.long, qty=qty_l, comment=_id)
            strategy.exit("L_TP1", from_entry="Long", qty_percent=33.3, limit=close + riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=close + 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

do_sell(_id, _sl, _riskPct) =>
    bool executed = false
    if strategy.position_size >= 0
        float riskPerShare = _sl - close
        if riskPerShare > 0
            float riskAmount = strategy.equity * (_riskPct / 100.0)
            float qty_s = riskAmount / riskPerShare
            strategy.entry("Short", strategy.short, qty=qty_s, comment=_id)
            strategy.exit("S_TP1", from_entry="Short", qty_percent=33.3, limit=close - riskPerShare, stop=_sl, comment_profit="TP1", comment_loss="SL")
            strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=close - 2*riskPerShare, stop=_sl, comment_profit="TP2", comment_loss="SL")
            strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=_sl, comment_profit="Run", comment_loss="SL")
            executed := true
    executed

// step 7.2: 信号触发 (Signal Trigger)
// --------------------------------------------------------------------------
bool stroke_updated = madePH or madePL

if useC1ForEntry and stroke_updated
    if c1Buy
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C1", c1BuyPx, risk_per_trade)
            g_long_entry := close
            g_long_sl := c1BuyPx
            g_long_stage := 0
        c1Buy := false // Reset flag

    if c1Sell
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C1", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c1Sell := false

if stroke_updated
    if c2BuyTrig
        if strategy.position_size < 0 
            strategy.close("Short", comment="Short Run Exit")
        if do_buy("Long_C2", c1BuyPx, risk_per_trade)
            g_long_entry := close, g_long_sl := c1BuyPx, g_long_stage := 0
        c2BuyTrig := false

    if c2SellTrig
        if strategy.position_size > 0 
            strategy.close("Long", comment="Long Run Exit")
        if do_sell("Short_C2", c1SellPx, risk_per_trade)
            g_short_entry := close, g_short_sl := c1SellPx, g_short_stage := 0
        c2SellTrig := false

    if c3Buy
        float sl_val = not na(centerSt.zg) ? centerSt.zg : c1BuyPx
        float lastZG = na
        if centers.size() > 0
            lastZG := centers.get(centers.size()-1).zg
        
        float final_sl = not na(lastZG) ? lastZG : c1BuyPx
        
        if do_buy("Long_C3", final_sl, risk_per_trade)
            g_long_entry := close
            g_long_sl := final_sl
            g_long_stage := 0
        c3Buy := false

    if c3Sell
        float lastZD = na
        if centers.size() > 0
            lastZD := centers.get(centers.size()-1).zd
        
        float final_sl_s = not na(lastZD) ? lastZD : c1SellPx
        
        if do_sell("Short_C3", final_sl_s, risk_per_trade)
            g_short_entry := close, g_short_sl := final_sl_s
            g_short_stage := 0
        c3Sell := false

// step 7.3: 动态止盈止损 (Dynamic SL/TP)
// --------------------------------------------------------------------------
if strategy.position_size > 0 and not na(g_long_entry) and not na(g_long_sl)
    risk = g_long_entry - g_long_sl
    if high >= (g_long_entry + risk) and g_long_stage < 1
        g_long_stage := 1
        strategy.exit("L_TP2", from_entry="Long", qty_percent=33.3, limit=g_long_entry + 2*risk, stop=g_long_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry, comment_profit="Run", comment_loss="SL_BE")
    if high >= (g_long_entry + 2*risk) and g_long_stage < 2
        g_long_stage := 2
        strategy.exit("L_Run", from_entry="Long", qty_percent=100, stop=g_long_entry + risk, comment_profit="Run", comment_loss="SL_1R")

if strategy.position_size < 0 and not na(g_short_entry) and not na(g_short_sl)
    risk = g_short_sl - g_short_entry
    if low <= (g_short_entry - risk) and g_short_stage < 1
        g_short_stage := 1
        strategy.exit("S_TP2", from_entry="Short", qty_percent=33.3, limit=g_short_entry - 2*risk, stop=g_short_entry, comment_profit="TP2", comment_loss="SL_BE")
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry, comment_profit="Run", comment_loss="SL_BE")
    if low <= (g_short_entry - 2*risk) and g_short_stage < 2
        g_short_stage := 2
        strategy.exit("S_Run", from_entry="Short", qty_percent=100, stop=g_short_entry - risk, comment_profit="Run", comment_loss="SL_1R")

// Manual Aux Lines
man_Enable = input.bool(false, "启用手动辅助线", group=grpMoney)
man_EntryPrice_str = input.string("", "手动入场价", group=grpMoney)
man_EntryPrice_val = str.length(man_EntryPrice_str) == 0 ? na : str.tonumber(man_EntryPrice_str)

if man_Enable and not na(man_EntryPrice_val)
    line.new(bar_index, man_EntryPrice_val, bar_index+10, man_EntryPrice_val, color=color.white, width=2)